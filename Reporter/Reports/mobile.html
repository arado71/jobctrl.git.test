<!DOCTYPE html>
<html>
<meta charset="utf-8">
<script type='text/javascript' src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
<script type='text/javascript' src="http://code.jquery.com/jquery-migrate-1.2.1.min.js"></script>
<script type='text/javascript' src='http://d3js.org/d3.v3.min.js'></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.22.1/js/jquery.tablesorter.min.js"></script>
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.22.1/css/theme.blue.min.css" />
<!--script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.0.4/d3.js"></script-->

<style type='text/css'>
    @import url(http://fonts.googleapis.com/css?family=Exo+2:400, 200, 200italic);

    body {
        background: #fff;
        color: #000;
        width: 100%;
        font-family: 'Exo 2', sans-serif;
    }

    .tooltip {
        color: white;
        opacity: .9;
        background: #333;
        bottom: 0px;
        left: 0px;
        padding: 5px;
        border: 1px solid lightgrey;
        border-radius: 5px;
        position: absolute;
        z-index: 10;
        visibility: hidden;
        white-space: nowrap;
        overflow-y: scroll;
        font: 12px sans-serif;
        max-height: 100%;
    }

    #chart_placeholder {
        text-align: center;
        margin: 20px 20px 20px 0px;
        color: #fff;
        position: absolute;
        height: 100%;
        width: 900px;
    }

    #circle circle {
        fill: none;
        pointer-events: all;
    }

    path.chord {
        stroke: #000;
        transition: opacity 0.3s;
        fill-opacity: .8;
        stroke-width: .25px;
    }

    .group {
        fill-opacity: .8;
    }

    #circle:hover path.fade, #circle path.mustFade, .hiddenRow {
        display: none;
    }

    text {
        fill: #000;
    }

    svg {
        font-size: 12px;
        color: #000;
        font-family: 'Exo 2', sans-serif;
        min-height: 100%;
        min-width: 100%;
    }

    button:disabled {
        color: darkgray;
        background-color: gray;
    }
</style>
<!--script src="http://d3js.org/d3.v2.min.js?2.8.1"></script-->
<!--script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script-->
<body>
    <script>
        window.onload = function () {
            /*** Define parameters and tools ***/
            var width = 920,
                height = 920,
                outerRadius = Math.min(width, height) / 2 - 100,
                innerRadius = outerRadius - 18;

            var dataset = "matrix.json";
            var sumTime = 0;
            //var dataset = "#all_trips";

            //string url for the initial data set
            //would usually be a file path url, here it is the id
            //selector for the <pre> element storing the data

            //create number formatting functions
            var formatMinuteSecond = function (t) {
                t = Math.round(t);
                var s = t % 60;
                var m = ((t - s) / 60) % 60;
                var h = (t - s - 60 * m) / 60 / 60;
                var res = "";
                if (h < 10) {
                    res += "0";
                }
                res += h + ":";
                if (m < 10) {
                    res += "0";
                }
                res += m + ":";
                if (s < 10) {
                    res += "0";
                }
                res += s;
                return res;
            };
            var formatPercent = d3.format(".1%");
            var numberWithCommas = d3.format("0,f");

            //create the arc path data generator for the groups
            var arc = d3.svg.arc()
                .innerRadius(innerRadius)
                .outerRadius(outerRadius);

            //create the chord path data generator for the chords
            var path = d3.svg.chord()
                .radius(innerRadius);

            //define the default chord layout parameters
            //within a function that returns a new layout object;
            //that way, you can create multiple chord layouts
            //that are the same except for the data.
            function getDefaultLayout() {
                return d3.layout.chord()
                .padding(0.00)
                .sortSubgroups(d3.descending)
                .sortChords(d3.ascending);
            }
            var last_layout; //store layout between updates
            var users; //store user data outside data-reading function

            /*** Initialize the visualization ***/
            var g = d3.select("#chart_placeholder").append("svg")
                    .attr("width", width)
                    .attr("height", height)
                .append("g")
                    .attr("id", "circle")
                    .attr("transform",
                          "translate(" + width / 2 + "," + height / 2 + ")");
            //the entire graphic will be drawn within this <g> element,
            //so all coordinates will be relative to the center of the circle

            g.append("circle")
                .attr("r", outerRadius);
            //this circle is set in CSS to be transparent but to respond to mouse events
            //It will ensure that the <g> responds to all mouse events within
            //the area, even after chords are faded out.

            /*** Read in the neighbourhoods data and update with initial data matrix ***/
            //normally this would be done with file-reading functions
            //d3.csv and d3.json and callbacks,
            //instead we're using the string-parsing functions
            //d3.csv.parse and JSON.parse, both of which return the data,
            //no callbacks required.

            /*
            d3.csv("data/users.csv", function(error, neighborhoodData) {

                if (error) {alert("Error reading file: ", error.statusText); return; }

                users = neighborhoodData;
                    //store in variable accessible by other functions

            */
            //users = d3.csv.parse(d3.select("#users").text());
            users = {};
            d3.json(dataset, function (mx) {
                if (!mx.hasOwnProperty('in')) {
                    d3.select("#dirButtons").style("display", "none");
                }
            });
            d3.csv("users.csv", function (myusers) {
                users = myusers;
                var t = d3.select("#UserTable");
                var tr = t.append("thead").append("tr");
                tr.append("th").text("Show");
                tr.append("th").text("Name");
                t = t.append("tbody");
                for (var i = 0; i < users.length; i++) {
                    var crow = t.append("tr").attr("data-id", i);
                    crow.append("td").append("input").attr("type", "checkbox").property("checked", "true").attr("data-id", i);
                    crow.append("td").text(users[i].name);
                }
                users[users.length] = { name: 'Others', color: '#777777' };
                updateChordDia();
            });
            //instead of d3.csv


            //call the update method with the default dataset

            //} ); //end of d3.csv function

            function updateTable(rawMatrix) {
                d3.select("#tabularData>table").remove();
                var t = d3.select("#tabularData").append("table");
                var frow = t.append("thead").append("tr");
                frow.append("th").text("Name");
                frow.append("th").text("Total");
                frow.append("th").text("Origin");
                frow.append("th").text("Destination");
                t = t.append("tbody");
                for (var i = 0; i < rawMatrix.length; i++) {
                    var crow = t.append("tr").attr("data-id", i).on("mouseover", function (d) {
                        var ie = parseInt(this.dataset.id);
                        g.selectAll("path.chord").data(last_layout.chords(), chordKey).classed("mustFade", function (p) {
                            //returns true if *neither* the source or target of the chord
                            //matches the group that has been moused-over
                            return ((p.source.index != ie) && (p.target.index != ie));
                        });
                    });
                    crow.on("mouseout", function (d) {
                        g.selectAll("path.chord").data(last_layout.chords(), chordKey).classed("mustFade", false);
                    });
                    crow.append("td").text(users[i].name);
                    var s = 0;
                    var s2 = 0;
                    for (j = 0; j < rawMatrix.length; j++) {
                        s += rawMatrix[i][j];
                    }

                    for (j = 0; j < rawMatrix.length; j++) {
                        s2 += rawMatrix[j][i];
                    }

                    crow.append("td").text(formatMinuteSecond(s + s2));
                    crow.append("td").text(formatMinuteSecond(s));
                    crow.append("td").text(formatMinuteSecond(s2));
                }
                var sortIndex = 2;
                if (chordType == 'ShowDestinations') {
                    sortIndex = 3;
                } else if (chordType == 'ShowAll') {
                    sortIndex = 1;
                }
                $(document).ready(function () {
                    $("table").tablesorter({ theme: 'blue', headers: { 0: { sorter: "text" }, }, sortList: [[sortIndex, 1]] });
                });
            }

            function filterMatrix(matrix, coreUserList) {
                var userSet = {};
                coreUserList.forEach(function (e) {
                    userSet[e] = true;
                });
                var res = [];
                for (var y = 0; y < matrix.length; y++) {
                    res[y] = [];
                    for (var x = 0; x < matrix[y].length; x++) {
                        res[y][x] = Object.prototype.hasOwnProperty.call(userSet, x) || Object.prototype.hasOwnProperty.call(userSet, y) ? matrix[y][x] : 0.0;
                    }
                }

                return res;
            }

            /* Create OR update a chord layout from a data matrix */
            function updateChords(datasetURL, transformType, sourceType, fOthers, coreUserList) {
                d3.json(datasetURL, function (mx) {
                    /*  d3.json(datasetURL, function(error, matrix) {

                      if (error) {alert("Error reading file: ", error.statusText); return; }

                      */
                    if (coreUserList.length == 0) return;
                    var matrix = {};

                    if (sourceType == 'in') {
                        matrix = transpose(mx['in']);
                    } else if (sourceType == 'out') {
                        matrix = mx['out'];
                    } else if (sourceType == 'user') {
                        matrix = [];
                        for (var y = 0; y < mx['in'].length; y++) {
                            matrix[y] = [];
                            for (var x = 0; x < mx['in'][0].length; x++) {
                                matrix[y][x] = mx['in'][x][y] + mx['out'][y][x];
                            }
                        }
                    } else {
                        matrix = [];
                        for (var y = 0; y < mx['in'].length; y++) {
                            matrix[y] = [];
                            for (var x = 0; x < mx['in'][0].length; x++) {
                                matrix[y][x] = mx['in'][x][y] + mx['out'][x][y];
                            }
                        }
                    }

                    matrix = filterMatrix(matrix, coreUserList);
                    updateTable(matrix);

                    if (transformType == 'ShowDestinations') {
                        matrix = transpose(matrix);
                    } else if (transformType == 'ShowAll') {
                        var t = [];
                        for (var y = 0; y < matrix.length; y++) {
                            t[y] = [];
                            for (var x = 0; x < matrix[0].length; x++) {
                                t[y][x] = matrix[y][x] + matrix[x][y];
                            }
                        }
                        matrix = t;
                    }

                    sumTime = getSumTime(matrix);
                    if (fOthers) {
                        matrix = filterOthers(matrix);
                    } else {
                        $("tr").removeClass("hiddenRow");
                    }

                    filterZeroFromTable(matrix);

                    //JSON.parse( d3.select(datasetURL).text() );
                    //var matrix = JSON.parse( d3.select(datasetURL).text() );
                    // instead of d3.json

                    /* Compute chord layout. */
                    layout = getDefaultLayout(); //create a new layout object
                    layout.matrix(matrix);

                    /* Create/update "group" elements */
                    var groupG = g.selectAll("g.group")
                        .data(layout.groups(), function (d) {
                            return d.index;
                            //use a key function in case the
                            //groups are sorted differently between updates
                        });

                    groupG.exit()
                        .transition()
                            .duration(1500)
                            .attr("opacity", 0)
                            .remove(); //remove after transitions are complete

                    var newGroups = groupG.enter().append("g")
                        .attr("class", "group");
                    //the enter selection is stored in a variable so we can
                    //enter the <path>, <text>, and <title> elements as well


                    //Create the title tooltip for the new groups
                    newGroups.append("title");

                    //Update the (tooltip) title text based on the data
                    groupG.select("title")
                        .text(function (d, i) {
                            if (transformType == 'ShowDestinations') {
                                return [users[i].name, ": ", formatMinuteSecond(d.value), " (", formatPercent(d.value / sumTime), " of destinations"].join("");
                            } else if (transformType == 'ShowAll') {
                                return [users[i].name, ": ", formatMinuteSecond(d.value), " (", formatPercent(d.value / sumTime), ") of all"].join("");
                            }
                            return [users[i].name, ": ", formatMinuteSecond(d.value), " (", formatPercent(d.value / sumTime), ") of origins"].join("");
                        });

                    //create the arc paths and set the constant attributes
                    //(those based on the group index, not on the value)
                    newGroups.append("path")
                        .attr("id", function (d) {
                            return "group" + d.index;
                            //using d.index and not i to maintain consistency
                            //even if groups are sorted
                        })
                        .style("fill", function (d) { return users[d.index].color; })
                    //.style("stroke", function (d) { return d3.rgb(users[d.index].color).darker(); })
                    ;

                    //update the paths to match the layout
                    groupG.select("path")
                        .transition()
                            .duration(1500)
                            .attr("opacity", 0.5) //optional, just to observe the transition
                        .attrTween("d", arcTween(last_layout))
                            .transition().duration(100).attr("opacity", 1) //reset opacity
                    ;

                    //create the group labels
                    newGroups.append("svg:text")
                        .attr("xlink:href", function (d) {
                            return "#group" + d.index;
                        })
                        .attr("dy", ".35em")
                        .attr("color", "#fff")
                        .text(function (d) {
                            return users[d.index].name;
                        });

                    //position group labels to match layout
                    groupG.select("text")
                        .transition()
                            .duration(1500)
                            .attr("transform", function (d) {
                                d.angle = (d.startAngle + d.endAngle) / 2;
                                //store the midpoint angle in the data object

                                return "rotate(" + (d.angle * 180 / Math.PI - 90) + ")" +
                                    " translate(" + (innerRadius + 26) + ")" +
                                    (d.angle > Math.PI ? " rotate(180)" : " rotate(0)");
                                //include the rotate zero so that transforms can be interpolated
                            })
                            .attr("opacity", function (d) { return Math.abs(d.endAngle - d.startAngle) < 0.015 ? 0 : 1; }) // Remove the labels that don't fit.
                            .attr("text-anchor", function (d) {
                                return d.angle > Math.PI ? "end" : "begin";
                            });

                    // Remove the labels that don't fit. :(
                    //groupG.select("text").filter(function(d, i) { return Math.abs(d.endAngle - d.startAngle) < 0.01 })
                    //  .remove();

                    /* Create/update the chord paths */
                    var chordPaths = g.selectAll("path.chord")
                        .data(layout.chords(), chordKey);
                    //specify a key function to match chords
                    //between updates


                    //create the new chord paths
                    var newChords = chordPaths.enter()
                        .append("path")
                        .attr("class", "chord");

                    // Add title tooltip for each new chord.
                    newChords.append("title");

                    // Update all chord title texts
                    chordPaths.select("title")
                        .text(function (d) {
                            var sourceName = users[d.source.index].name;
                            var sourceValue = d.source.value;
                            var targetName = users[d.target.index].name;
                            var targetValue = d.target.value;
                            if (transformType == 'ShowDestinations') {
                                return [targetName
                                        , " → ", sourceName
                                        , ": ", formatMinuteSecond(sourceValue)
                                        , " ("
                                        , formatPercent(sourceValue / sumTime)
                                        , ")"
                                        , "\n", sourceName
                                        , " → ", targetName
                                        , ": ", formatMinuteSecond(targetValue)
                                        , " ("
                                        , formatPercent(targetValue / sumTime)
                                        , ")"
                                ].join("");
                            } else if (transformType == 'ShowAll') {
                                return [sourceName,
                                        , " - ", targetName
                                        , ": ", formatMinuteSecond(sourceValue)
                                        , " ("
                                        , formatPercent(sourceValue / sumTime)
                                        , ")"
                                ].join("");
                            }
                            return [sourceName,
                                    , " → ", targetName
                                    , ": ", formatMinuteSecond(sourceValue)
                                    , " ("
                                    , formatPercent(sourceValue / sumTime)
                                    , ")"
                                    , "\n", targetName
                                    , " → ", sourceName
                                    , ": ", formatMinuteSecond(targetValue)
                                    , " ("
                                    , formatPercent(targetValue / sumTime)
                                    , ")"
                            ].join("");
                        });

                    //handle exiting paths:
                    chordPaths.exit().transition()
                        .duration(1500)
                        .attr("opacity", 0)
                        .remove();

                    //update the path shape
                    chordPaths.transition()
                        .duration(1500)
                        .attr("opacity", 0.5) //optional, just to observe the transition
                        .style("fill", function (d) {
                            return users[d.source.index].color;
                        })
                        .attrTween("d", chordTween(last_layout))
                        .transition().duration(100).attr("opacity", 1) //reset opacity
                    ;

                    //add the mouseover/fade out behaviour to the groups
                    //this is reset on every update, so it will use the latest
                    //chordPaths selection
                    groupG.on("mouseover", function (d) {
                        chordPaths.classed("fade", function (p) {
                            //returns true if *neither* the source or target of the chord
                            //matches the group that has been moused-over
                            return ((p.source.index != d.index) && (p.target.index != d.index));
                        });
                    });
                    //g.on("mouseout", function (d) {
                    //    chordPaths.classed("fade",false);
                    //});

                    //the "unfade" is handled with CSS :hover class on g#circle
                    //you could also do it using a mouseout event:
                    /*
                    g.select("circle").on("mouseout", function() {
                        if (this == g.node() )
                            //only respond to mouseout of the entire circle
                            //not mouseout events for sub-components
                            chordPaths.classed("fade", false);
                    });
                    */


                    last_layout = layout; //save for next update

                }); //end of d3.json
            }

            function arcTween(oldLayout) {
                //this function will be called once per update cycle

                //Create a key:value version of the old layout's groups array
                //so we can easily find the matching group
                //even if the group index values don't match the array index
                //(because of sorting)
                var oldGroups = {};
                if (oldLayout) {
                    oldLayout.groups().forEach(function (groupData) {
                        oldGroups[groupData.index] = groupData;
                    });
                }

                return function (d, i) {
                    var tween;
                    var old = oldGroups[d.index];
                    if (old) { //there's a matching old group
                        tween = d3.interpolate(old, d);
                    }
                    else {
                        //create a zero-width arc object
                        var emptyArc = {
                            startAngle: d.startAngle,
                            endAngle: d.startAngle
                        };
                        tween = d3.interpolate(emptyArc, d);
                    }

                    return function (t) {
                        return arc(tween(t));
                    };
                };
            }

            function chordKey(data) {
                return (data.source.index < data.target.index) ?
                    data.source.index + "-" + data.target.index :
                    data.target.index + "-" + data.source.index;

                //create a key that will represent the relationship
                //between these two groups *regardless*
                //of which group is called 'source' and which 'target'
            }
            function chordTween(oldLayout) {
                //this function will be called once per update cycle

                //Create a key:value version of the old layout's chords array
                //so we can easily find the matching chord
                //(which may not have a matching index)

                var oldChords = {};

                if (oldLayout) {
                    oldLayout.chords().forEach(function (chordData) {
                        oldChords[chordKey(chordData)] = chordData;
                    });
                }

                return function (d, i) {
                    //this function will be called for each active chord

                    var tween;
                    var old = oldChords[chordKey(d)];
                    if (old) {
                        //old is not undefined, i.e.
                        //there is a matching old chord value

                        //check whether source and target have been switched:
                        if (d.source.index != old.source.index) {
                            //swap source and target to match the new data
                            old = {
                                source: old.target,
                                target: old.source
                            };
                        }

                        tween = d3.interpolate(old, d);
                    }
                    else {
                        //create a zero-width chord object
                        var emptyChord = {
                            source: {
                                startAngle: d.source.startAngle,
                                endAngle: d.source.startAngle
                            },
                            target: {
                                startAngle: d.target.startAngle,
                                endAngle: d.target.startAngle
                            }
                        };
                        tween = d3.interpolate(emptyChord, d);
                    }

                    return function (t) {
                        //this function calculates the intermediary shapes
                        return path(tween(t));
                    };
                };
            }

            chordType = "ShowOrigins";
            sourceType = "out";
            chordFilterOthers = !($("#ShowOthers").checked);

            d3.selectAll("button").attr("disabled", null);
            disableButton($("#ShowOrigins"));
            disableButton($("#ShowWrite"));

            function getUserList() {
                var res = [];
                $("#Filters input").each(function (e) {
                    if (this.checked) {
                        res.push(parseInt(this.dataset.id));
                    }
                });
                return res;
            }

            function updateChordDia() {
                updateChords("matrix.json", chordType, sourceType, chordFilterOthers, getUserList());
            }

            /* Activate the buttons and link to data sets */
            d3.select("#ShowOrigins").on("click", function () {
                chordType = "ShowOrigins";
                updateChordDia();
                //replace this with a file url as appropriate

                //enable other buttons, disable this one
                disableButton(this);
            });

            d3.select("#ShowDestinations").on("click", function () {
                chordType = "ShowDestinations";
                updateChordDia();
                disableButton(this);
            });

            d3.select("#ShowWrite").on("click", function () {
                sourceType = "out";
                updateChordDia();
                disableButton(this);
            });

            d3.select("#ShowRead").on("click", function () {
                sourceType = "in";
                updateChordDia();
                disableButton(this);
            });

            d3.select("#ShowUser").on("click", function () {
                sourceType = "user";
                updateChordDia();
                disableButton(this);
            });

            d3.select("#ShowTotal").on("click", function () {
                sourceType = "total";
                updateChordDia();
                disableButton(this);
            });

            d3.select("#ShowAll").on("click", function () {
                chordType = "ShowAll";
                updateChordDia();
                disableButton(this);
            });

            $("#ShowOthers").change(function () {
                chordFilterOthers = !this.checked;
                updateChordDia();
            });

            d3.select("#ShowFilter").on("click", function () {
                d3.select("#ShowFilter").style("visibility", "hidden");
                d3.select("#Filters").style("visibility", "visible");
            });

            d3.select("#ApplyFilter").on("click", function () {
                d3.select("#ShowFilter").style("visibility", "visible");
                d3.select("#Filters").style("visibility", "hidden");
                updateChordDia();
            });

            $("#AllOff").on("click", function () {
                d3.selectAll("#Filters input").property("checked", "");
            });

            $("#AllOn").on("click", function () {
                d3.selectAll("#Filters input").property("checked", "true");
            });

            function transpose(a) {
                return Object.keys(a[0]).map(
                    function (c) { return a.map(function (r) { return r[c]; }); }
                    );
            }

            function getSumTime(mx) {
                var s = 0;
                for (i = 0; i < mx.length; i++) {
                    for (j = 0; j < mx.length; j++) {
                        s += mx[i][j];
                    }
                }
                return s;
            }

            function filterZeroFromTable(mx) {
                for (var i = 0; i < mx.length; i++) {
                    var allCalls = 0;
                    for (j = 0; j < mx[i].length; j++) {
                        allCalls += mx[i][j] + mx[j][i];
                    }
                    if (allCalls == 0) {
                        $("#tabularData tr[data-id='" + i + "']").addClass("hiddenRow");
                    }
                }
            }

            function filterOthers(mx) {
                var matrix = [];
                var oIdx = mx.length;
                for (y = 0; y < mx.length + 1; y++) { matrix[y] = []; matrix[y][oIdx] = 0; }
                if (mx.length > 0) {
                    for (x = 0; x < mx[0].length + 1; x++) {
                        matrix[oIdx][x] = 0;
                    }
                }

                var others = [];
                for (i = 0; i < mx.length; i++) {
                    var allCalls = 0;
                    for (j = 0; j < mx.length; j++) {
                        allCalls += mx[i][j] + mx[j][i];
                    }
                    if (allCalls / sumTime < 0.001) {
                        others[i] = true;
                        $("#tabularData tr[data-id='" + i + "']").addClass("hiddenRow");
                    } else others[i] = false;
                }

                for (y = 0; y < mx.length; y++) {
                    for (x = 0; x < mx[0].length; x++) {

                        if (others[y] || others[x]) {
                            matrix[y][x] = 0;
                        }
                        else {
                            matrix[y][x] = mx[y][x];
                        }

                        if (others[y] && others[x]) {
                            matrix[oIdx][oIdx] += mx[y][x];
                        }
                        else if (others[y]) {
                            matrix[oIdx][x] += mx[y][x];
                        }
                        else if (others[x]) {
                            matrix[y][oIdx] += mx[y][x];
                        }
                    }
                }

                return matrix;
            }

            function disableButton(buttonNode) {
                d3.select(buttonNode.parentNode).selectAll("button")
                    .attr("disabled", function (d) {
                        return this === buttonNode ? "true" : null;
                    });
            }
        }
    </script>
    <div id="chart_placeholder"></div>
    <div id="tabularData" style="float: right; position: absolute; margin-top: 20px; margin-left: 940px; height: 100%; overflow-y: scroll"></div>
    <div id="dirButtons" style="float:left;">
        <button id="ShowWrite">Show Writes</button>
        <button id="ShowRead">Show Reads</button>
        <button id="ShowUser">Show User times</button>
        <button id="ShowTotal">Read&amp;Write</button>
    </div>
    <div style="float: left;">
        <button id="ShowOrigins">Show Origins</button>
        <button id="ShowDestinations">Show Destinations</button>
        <button id="ShowAll">Show All</button>
    </div>
    <label><input type="checkbox" id="ShowOthers">Show others</label>
    <button id="ShowFilter">Filtering</button>
    <div id="Filters" class="tooltip" style="visibility: hidden">
        <table id="UserTable"></table>
        <button id="ApplyFilter">Close</button>
        <button id="AllOff">Off</button>
        <button id="AllOn">On</button>
    </div>
</body>
</html>