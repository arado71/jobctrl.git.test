/*
Deployment script for recorder

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
/*
:setvar DatabaseName "recorder"
:setvar DefaultFilePrefix "recorder"
:setvar DefaultDataPath ""
:setvar DefaultLogPath ""
*/

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
PRINT N'Altering [dbo].[GetSchemaVersion]...';


GO
-- Don't modify this file, it's used in the build process!
ALTER PROCEDURE [dbo].[GetSchemaVersion]
AS RETURN 53
GO
PRINT N'Altering [dbo].[MergeAggregateIdleIntervals]...';


GO
--this sproc should not be called directly, its only called by [UpdateHourlyAggregateWorkItems]
ALTER PROCEDURE [dbo].[MergeAggregateIdleIntervals]
	(
	@startDate datetime
	)
AS
	SET NOCOUNT ON

IF @startDate IS NULL RETURN

SET XACT_ABORT ON
BEGIN TRAN

declare
@c_phaseId uniqueidentifier,
@c_firstId bigint,
@c_secondId bigint,
@c_secondEndDate datetime,
@p_phaseId uniqueidentifier,
@p_firstId bigint = -1,
@p_secondEndDate datetime,
@is_afterLast bit

DECLARE @idTable TABLE (id int)


-- StartDate and PhaseId is unique in WorkItems so it should be unique in AggregateIdleIntervals too.
-- That means that we can only find at most one match for each interval to merge. (no dupes on join)
-- Without the PhaseId we could use row_number to only fetch the first match if there are more.
DECLARE merge_cursor CURSOR LOCAL STATIC FORWARD_ONLY FOR 
SELECT f.[PhaseId]
      ,f.[Id]
      ,s.[Id]
      ,s.[EndDate]
  FROM [dbo].[AggregateIdleIntervals] f (TABLOCKX)
  JOIN [dbo].[AggregateIdleIntervals] s
		ON 	f.[EndDate] = s.[StartDate]
		AND f.[WorkId] = s.[WorkId]
		AND f.[UserId] = s.[UserId]
		AND f.[GroupId] = s.[GroupId]
		AND f.[CompanyId] = s.[CompanyId]
		AND f.[PhaseId] = s.[PhaseId]
		AND f.[ComputerId] = s.[ComputerId]
		AND f.[IsRemoteDesktop] = s.[IsRemoteDesktop]
		AND f.[IsVirtualMachine] = s.[IsVirtualMachine]
 		AND f.[Id] <> s.[Id]
 WHERE 
        f.[EndDate] >= @startDate 
        AND s.[EndDate] >= @startDate
ORDER BY f.[PhaseId], f.[WorkId], f.[UserId], f.[GroupId], f.[CompanyId], f.[ComputerId], f.[IsRemoteDesktop], f.[IsVirtualMachine], f.[EndDate] DESC
OPTION (RECOMPILE)

OPEN merge_cursor

WHILE @is_afterLast IS NULL
BEGIN
	FETCH NEXT FROM merge_cursor INTO 
		@c_phaseId,
		@c_firstId,
		@c_secondId,
		@c_secondEndDate

	IF @@FETCH_STATUS <> 0
		SET @is_afterLast = 1

	IF @p_firstId = -1 
	BEGIN
		SET @p_firstId = @c_firstId
		SET @p_secondEndDate = @c_secondEndDate
		SET @p_phaseId = @c_phaseId
		INSERT INTO @idTable VALUES (@c_secondId)
		CONTINUE
	END

	IF @p_phaseId = @c_phaseId AND @p_firstId = @c_secondId AND @is_afterLast IS NULL
	BEGIN
		SET @p_firstId = @c_firstId
		INSERT INTO @idTable VALUES (@c_secondId)
		CONTINUE
	END

	--delete the second intervals
	DELETE FROM [dbo].[AggregateIdleIntervals] WHERE Id in (SELECT id FROM @idTable)
	IF @@rowcount = 0 CONTINUE --already deleted??

	--extend the first interval
	UPDATE [dbo].[AggregateIdleIntervals] 
	   SET [EndDate] = @p_secondEndDate,
		   [UpdateDate] = GETUTCDATE()
	 WHERE Id = @p_firstId

	DELETE @idTable
	SET @p_firstId = @c_firstId
	SET @p_secondEndDate = @c_secondEndDate
	SET @p_phaseId = @c_phaseId
	INSERT INTO @idTable VALUES (@c_secondId)

END

CLOSE merge_cursor
DEALLOCATE merge_cursor
	
COMMIT TRAN	
	RETURN
GO
PRINT N'Altering [dbo].[MergeAggregateWorkItemIntervals]...';


GO
--this sproc should not be called directly, its only called by [UpdateHourlyAggregateWorkItems]
ALTER PROCEDURE [dbo].[MergeAggregateWorkItemIntervals]
	(
	@startDate datetime
	)
AS
	SET NOCOUNT ON

IF @startDate IS NULL RETURN

SET XACT_ABORT ON
BEGIN TRAN

declare
@c_phaseId uniqueidentifier,
@c_firstId bigint,
@c_secondId bigint,
@c_secondEndDate datetime,
@p_phaseId uniqueidentifier,
@p_firstId bigint = -1,
@p_secondEndDate datetime,
@is_afterLast bit

DECLARE @idTable TABLE (id int)

-- StartDate and PhaseId is unique in WorkItems so it should be unique in AggregateWorkItemIntervals too.
-- That means that we can only find at most one match for each interval to merge. (no dupes on join)
-- Without the PhaseId we could use row_number to only fetch the first match if there are more.
DECLARE merge_cursor CURSOR LOCAL STATIC FORWARD_ONLY FOR 
SELECT f.[PhaseId]
      ,f.[Id]
      ,s.[Id]
      ,s.[EndDate]
  FROM [dbo].[AggregateWorkItemIntervals] f (TABLOCKX)
  JOIN [dbo].[AggregateWorkItemIntervals] s
		ON 	f.[EndDate] = s.[StartDate]
		AND f.[WorkId] = s.[WorkId]
		AND f.[UserId] = s.[UserId]
		AND f.[GroupId] = s.[GroupId]
		AND f.[CompanyId] = s.[CompanyId]
		AND f.[PhaseId] = s.[PhaseId]
		AND f.[ComputerId] = s.[ComputerId]
		AND f.[IsRemoteDesktop] = s.[IsRemoteDesktop]
		AND f.[IsVirtualMachine] = s.[IsVirtualMachine]
		AND f.[Id] <> s.[Id]
 WHERE 
        f.[EndDate] >= @startDate 
        AND s.[EndDate] >= @startDate
ORDER BY f.[PhaseId], f.[WorkId], f.[UserId], f.[GroupId], f.[CompanyId], f.[ComputerId], f.[IsRemoteDesktop], f.[IsVirtualMachine], f.[EndDate] DESC
OPTION (RECOMPILE)

OPEN merge_cursor

WHILE @is_afterLast IS NULL
BEGIN
	FETCH NEXT FROM merge_cursor INTO 
		@c_phaseId,
		@c_firstId,
		@c_secondId,
		@c_secondEndDate
	IF @@FETCH_STATUS <> 0
		SET @is_afterLast = 1

	IF @p_firstId = -1 
	BEGIN
		SET @p_firstId = @c_firstId
		SET @p_secondEndDate = @c_secondEndDate
		SET @p_phaseId = @c_phaseId
		INSERT INTO @idTable VALUES (@c_secondId)
		CONTINUE
	END

	IF @p_phaseId = @c_phaseId AND @p_firstId = @c_secondId AND @is_afterLast IS NULL
	BEGIN
		SET @p_firstId = @c_firstId
		INSERT INTO @idTable VALUES (@c_secondId)
		CONTINUE
	END

	--delete the second intervals
	DELETE FROM [dbo].[AggregateWorkItemIntervals] WHERE Id in (SELECT id FROM @idTable)
	IF @@rowcount = 0 CONTINUE --already deleted??

	--extend the first interval
	UPDATE [dbo].[AggregateWorkItemIntervals] 
	   SET [EndDate] = @p_secondEndDate,
		   [UpdateDate] = GETUTCDATE()
	 WHERE Id = @p_firstId

	DELETE @idTable
	SET @p_firstId = @c_firstId
	SET @p_secondEndDate = @c_secondEndDate
	SET @p_phaseId = @c_phaseId
	INSERT INTO @idTable VALUES (@c_secondId)

END

CLOSE merge_cursor
DEALLOCATE merge_cursor
	
COMMIT TRAN	
	RETURN
GO
PRINT N'Altering [dbo].[UpdateHourlyAggregateWorkItemsFromId]...';


GO
--this sproc should not be called directly, its only called by [UpdateHourlyAggregateWorkItems]
ALTER PROCEDURE [dbo].[UpdateHourlyAggregateWorkItemsFromId]
	(
	@StartId bigint,
	@EndId bigint OUTPUT,
	@MinStartDate datetime = NULL OUTPUT
	)
AS
	SET NOCOUNT ON

SET XACT_ABORT ON
BEGIN TRAN
SET @EndId = @StartId

declare @StartIdChk bigint
SET @StartIdChk = (SELECT ISNULL(MAX(LastAggregatedId),0) FROM dbo.AggregateLastWorkItem)
IF @StartId <> @StartIdChk
BEGIN
	RAISERROR('UpdateHourlyAggregateWorkItemsFromId called with wrong StartId',16,1)
	ROLLBACK
	RETURN
END

declare @MaxEndId bigint
SET @MaxEndId = (SELECT ISNULL(MAX(Id),0) FROM [dbo].[WorkItems] WITH (TABLOCK)) -- I suppose TABLOCK is enough and no TABLOCKX needed
--using TABLOCKX (without HOLDLOCK) would cause to hold the lock until the end of the transaction.

declare
@c_Id bigint = -1,
@c_WorkId int,
@c_PhaseId uniqueidentifier,
@c_StartDate datetime,
@c_EndDate datetime,
@c_UserId int,
@c_GroupId int,
@c_CompanyId int,
@c_ComputerId int,
@c_IsRemoteDesktop bit,
@c_IsVirtualMachine bit,
@c_MouseActivity int,
@c_KeyboardActivity int,
@is_cut_needed bit,
@is_afterLast bit,
@i_StartDate datetime = null,
@i_EndDate datetime

declare
@f_Id bigint,
@f_WorkId int,
@f_PhaseId uniqueidentifier,
@f_StartDate datetime,
@f_EndDate datetime,
@f_UserId int,
@f_GroupId int,
@f_CompanyId int,
@f_ComputerId int,
@f_IsRemoteDesktop bit,
@f_IsVirtualMachine bit,
@f_MouseActivity int,
@f_KeyboardActivity int

DECLARE interval_cursor CURSOR LOCAL FAST_FORWARD FOR 
SELECT [Id]
      ,[WorkId]
      ,[PhaseId]
      ,[StartDate]
      ,[EndDate]
      ,[UserId]
      ,[GroupId]
      ,[CompanyId]
      ,[ComputerId]
	  ,[IsRemoteDesktop]
	  ,[IsVirtualMachine]
      ,[MouseActivity]
      ,[KeyboardActivity]
  FROM [dbo].[WorkItems] --(TABLOCKX) we don't need locking if we have the @MaxEndId
  WITH (INDEX (PK_Workitems))
 WHERE [Id] > @StartId
   AND [Id] <= @MaxEndId
 ORDER BY UserId, ComputerId, PhaseId, WorkId, StartDate

OPEN interval_cursor

WHILE @is_afterLast IS NULL
BEGIN
	FETCH NEXT FROM interval_cursor INTO 
		@f_Id,
		@f_WorkId,
		@f_PhaseId,
		@f_StartDate,
		@f_EndDate,
		@f_UserId,
		@f_GroupId,
		@f_CompanyId,
		@f_ComputerId,
		@f_IsRemoteDesktop,
		@f_IsVirtualMachine,
		@f_MouseActivity,
		@f_KeyboardActivity

	IF @@FETCH_STATUS <> 0
		SET @is_afterLast = 1

	IF (@f_StartDate>=@f_EndDate AND @is_afterLast IS NULL) CONTINUE

	IF (@c_id = -1) -- first row
	BEGIN
		SET @c_Id				= @f_Id
		SET @c_WorkId			= @f_WorkId
		SET @c_PhaseId			= @f_PhaseId
		SET @c_StartDate		= @f_StartDate
		SET @c_EndDate			= @f_EndDate
		SET @c_UserId			= @f_UserId
		SET @c_GroupId			= @f_GroupId
		SET @c_CompanyId		= @f_CompanyId
		SET @c_ComputerId		= @f_ComputerId
		SET @c_IsRemoteDesktop	= @f_IsRemoteDesktop
		SET @c_IsVirtualMachine	= @f_IsVirtualMachine
		SET @c_MouseActivity	= @f_MouseActivity
		SET @c_KeyboardActivity	= @f_KeyboardActivity
		SET @is_cut_needed = 0
	END
	ELSE
	IF (@c_UserId = @f_UserId
		AND @c_ComputerId = @f_ComputerId
		AND @c_GroupId = @f_GroupId
		AND @c_CompanyId = @f_CompanyId
		AND @c_PhaseId = @f_PhaseId
		AND @c_WorkId = @f_WorkId
		AND @c_IsRemoteDesktop = @f_IsRemoteDesktop
		AND @c_IsVirtualMachine = @f_IsVirtualMachine
		--AND (@c_MouseActivity + @c_KeyboardActivity = 0 AND @f_MouseActivity + @f_KeyboardActivity = 0 OR @c_MouseActivity + @c_KeyboardActivity <> 0 AND @f_MouseActivity + @f_KeyboardActivity <> 0)
		AND @c_EndDate = @f_StartDate) -- connected workitem
		AND @is_afterLast IS NULL
		SET @is_cut_needed = 0
	ELSE
		SET @is_cut_needed = 1

	IF @is_cut_needed = 1
	BEGIN
		IF (@EndId<@c_Id)  SET @EndId = @c_Id
		IF (@MinStartDate IS NULL OR @MinStartDate > @c_StartDate) SET @MinStartDate = @c_StartDate

		UPDATE TOP (1) [dbo].[AggregateWorkItemIntervals] 
		   SET [EndDate] = @c_EndDate,
			   [UpdateDate] = GETUTCDATE()
		 WHERE EndDate = @c_StartDate --enddate should match
		   AND PhaseId = @c_PhaseId
		   AND WorkId = @c_WorkId
		   AND UserId = @c_UserId
		   AND GroupId = @c_GroupId
		   AND CompanyId = @c_CompanyId
		   AND ComputerId = @c_ComputerId
		   AND IsRemoteDesktop = @c_IsRemoteDesktop
		   AND IsVirtualMachine = @c_IsVirtualMachine

		IF @@rowcount = 0
		BEGIN
			INSERT INTO [dbo].[AggregateWorkItemIntervals]
					   ([WorkId]
					   ,[StartDate]
					   ,[EndDate]
					   ,[UserId]
					   ,[GroupId]
					   ,[CompanyId]
					   ,[PhaseId]
					   ,[ComputerId]
					   ,[IsRemoteDesktop]
					   ,[IsVirtualMachine]
					   ,[CreateDate]
					   ,[UpdateDate])
				 VALUES
					   (@c_WorkId
					   ,@c_StartDate
					   ,@c_EndDate
					   ,@c_UserId
					   ,@c_GroupId
					   ,@c_CompanyId
					   ,@c_PhaseId
					   ,@c_ComputerId
					   ,@c_IsRemoteDesktop
					   ,@c_IsVirtualMachine
					   ,GETUTCDATE()
					   ,GETUTCDATE())
		END	
		--END update AggregateWorkItemIntervals
	END

	--BEGIN update AggregateIdleIntervals	
	IF (@f_MouseActivity <> 0 OR @f_KeyboardActivity <> 0 OR @is_cut_needed = 1) AND  @i_StartDate IS NOT NULL 
	BEGIN
		UPDATE TOP (1) [dbo].[AggregateIdleIntervals] 
		   SET [EndDate] = @i_EndDate,
			   [UpdateDate] = GETUTCDATE()
		 WHERE EndDate = @i_StartDate --enddate should match
		   AND PhaseId = @c_PhaseId
		   AND WorkId = @c_WorkId
		   AND UserId = @c_UserId
		   AND GroupId = @c_GroupId
		   AND CompanyId = @c_CompanyId
		   AND ComputerId = @c_ComputerId
	       AND IsRemoteDesktop = @c_IsRemoteDesktop
		   AND IsVirtualMachine = @c_IsVirtualMachine

		IF @@rowcount = 0
		BEGIN
			INSERT INTO [dbo].[AggregateIdleIntervals]
					   ([WorkId]
					   ,[StartDate]
					   ,[EndDate]
					   ,[UserId]
					   ,[GroupId]
					   ,[CompanyId]
					   ,[PhaseId]
					   ,[ComputerId]
					   ,[IsRemoteDesktop]
					   ,[IsVirtualMachine]
					   ,[CreateDate]
					   ,[UpdateDate])
				 VALUES
					   (@c_WorkId
					   ,@i_StartDate
					   ,@i_EndDate
					   ,@c_UserId
					   ,@c_GroupId
					   ,@c_CompanyId
					   ,@c_PhaseId
					   ,@c_ComputerId
					   ,@c_IsRemoteDesktop
					   ,@c_IsVirtualMachine
					   ,GETUTCDATE()
					   ,GETUTCDATE())
		END

		SET @i_StartDate = NULL
	END

	IF @f_MouseActivity = 0 AND @f_KeyboardActivity = 0
	BEGIN
		IF @i_StartDate IS NULL SET @i_StartDate = @f_StartDate
		SET @i_EndDate = @f_EndDate
	END
	--END update AggregateIdleIntervals

	IF @is_cut_needed = 1
	BEGIN
		SET @c_Id				= @f_Id
		SET @c_WorkId			= @f_WorkId
		SET @c_PhaseId			= @f_PhaseId
		SET @c_StartDate		= @f_StartDate
		SET @c_EndDate			= @f_EndDate
		SET @c_UserId			= @f_UserId
		SET @c_GroupId			= @f_GroupId
		SET @c_CompanyId		= @f_CompanyId
		SET @c_ComputerId		= @f_ComputerId
		SET @c_IsRemoteDesktop	= @f_IsRemoteDesktop
		SET @c_IsVirtualMachine	= @f_IsVirtualMachine
		SET @c_MouseActivity	= @f_MouseActivity
		SET @c_KeyboardActivity	= @f_KeyboardActivity
	END
	ELSE
	BEGIN
		SET @c_EndDate = @f_EndDate
		SET @c_KeyboardActivity = @c_KeyboardActivity + @f_KeyboardActivity
		SET @c_MouseActivity = @c_MouseActivity + @f_MouseActivity
	END
END
CLOSE interval_cursor
DEALLOCATE interval_cursor

COMMIT TRAN	
	
	RETURN
GO
PRINT N'Refreshing [dbo].[UpdateHourlyAggregateWorkItems]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[UpdateHourlyAggregateWorkItems]';


GO
PRINT N'Update complete.';


GO
