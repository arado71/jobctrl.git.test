/*
Deployment script for recorder

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
/*
:setvar DatabaseName "recorder"
:setvar DefaultFilePrefix "recorder"
:setvar DefaultDataPath ""
:setvar DefaultLogPath ""
*/

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
PRINT N'Altering [dbo].[ClientSettings]...';


GO
ALTER TABLE [dbo].[ClientSettings]
    ADD [CollectorRules]        NVARCHAR (MAX) COLLATE SQL_Latin1_General_CP1_CI_AS NULL,
        [CollectorRulesVersion] BINARY (8)     DEFAULT ((0)) NOT NULL;


GO
PRINT N'Creating [dbo].[CollectedItems]...';


GO
CREATE TABLE [dbo].[CollectedItems] (
    [UserId]     INT      NOT NULL,
    [CreateDate] DATETIME NOT NULL,
    [ComputerId] INT      NOT NULL,
    [KeyId]      INT      NOT NULL,
    [ValueId]    INT      NULL
);


GO
PRINT N'Creating [dbo].[CollectedItems].[IX_CollectedItems_CreateDate_Clust]...';


GO
CREATE CLUSTERED INDEX [IX_CollectedItems_CreateDate_Clust]
    ON [dbo].[CollectedItems]([CreateDate] ASC);


GO
PRINT N'Creating [dbo].[CollectedItems].[IX_CollectedItems_UserId_CreateDate_Covered]...';


GO
CREATE NONCLUSTERED INDEX [IX_CollectedItems_UserId_CreateDate_Covered]
    ON [dbo].[CollectedItems]([UserId] ASC, [CreateDate] ASC)
    INCLUDE([ComputerId], [KeyId], [ValueId]);


GO
PRINT N'Creating [dbo].[CollectedKeyLookup]...';


GO
CREATE TABLE [dbo].[CollectedKeyLookup] (
    [Id]       INT             IDENTITY (1, 1) NOT NULL,
    [HashCode] INT             NOT NULL,
    [Key]      NVARCHAR (4000) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
    CONSTRAINT [PK_CollectedKeyLookup] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [dbo].[CollectedKeyLookup].[IX_CollectedKeyLookup_HashCode]...';


GO
CREATE NONCLUSTERED INDEX [IX_CollectedKeyLookup_HashCode]
    ON [dbo].[CollectedKeyLookup]([HashCode] ASC);


GO
PRINT N'Creating [dbo].[CollectedValueLookup]...';


GO
CREATE TABLE [dbo].[CollectedValueLookup] (
    [Id]       INT             IDENTITY (1, 1) NOT NULL,
    [HashCode] INT             NOT NULL,
    [Value]    NVARCHAR (4000) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL,
    CONSTRAINT [PK_CollectedValueLookup] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [dbo].[CollectedValueLookup].[IX_CollectedValueLookup_HashCode]...';


GO
CREATE NONCLUSTERED INDEX [IX_CollectedValueLookup_HashCode]
    ON [dbo].[CollectedValueLookup]([HashCode] ASC);


GO
PRINT N'Creating FK_CollectedItems_CollectedKeyLookup...';


GO
ALTER TABLE [dbo].[CollectedItems] WITH NOCHECK
    ADD CONSTRAINT [FK_CollectedItems_CollectedKeyLookup] FOREIGN KEY ([KeyId]) REFERENCES [dbo].[CollectedKeyLookup] ([Id]);


GO
PRINT N'Creating FK_CollectedItems_CollectedValueLookup...';


GO
ALTER TABLE [dbo].[CollectedItems] WITH NOCHECK
    ADD CONSTRAINT [FK_CollectedItems_CollectedValueLookup] FOREIGN KEY ([ValueId]) REFERENCES [dbo].[CollectedValueLookup] ([Id]);


GO
PRINT N'Altering [dbo].[ClientSettings_Versions_I]...';


GO
ALTER TRIGGER [dbo].[ClientSettings_Versions_I]
	ON [dbo].[ClientSettings]
	AFTER INSERT
	AS
	BEGIN
		SET NOCOUNT ON
		DECLARE @nextValue BINARY(8)
		EXEC GetNextValueForSequence @nextValue OUTPUT
		UPDATE [dbo].[ClientSettings] SET MenuVersion=@nextValue, WorkDetectorRulesVersion=@nextValue, CensorRulesVersion=@nextValue, ClientSettingsVersion=@nextValue, CollectorRulesVersion=@nextValue WHERE UserId IN (SELECT UserId FROM inserted)
	END
GO
PRINT N'Altering [dbo].[ClientSettings_Versions_U]...';


GO
ALTER TRIGGER [dbo].[ClientSettings_Versions_U]
	ON [dbo].[ClientSettings]
	AFTER UPDATE
	AS
	BEGIN
		SET NOCOUNT ON
		DECLARE @nextValue BINARY(8)
		EXEC GetNextValueForSequence @nextValue OUTPUT
		IF ( UPDATE (Menu) ) 
		BEGIN
			UPDATE [ClientSettings] SET MenuVersion = @nextValue WHERE UserId IN (SELECT i.UserId FROM inserted i JOIN deleted d ON i.UserId = d.UserId WHERE i.Menu <> d.Menu OR (i.Menu IS NOT NULL AND d.Menu IS NULL) OR (i.Menu IS NULL AND d.Menu IS NOT NULL))
		END
		IF ( UPDATE (WorkDetectorRules) ) 
		BEGIN
			UPDATE [ClientSettings] SET WorkDetectorRulesVersion = @nextValue WHERE UserId IN (SELECT i.UserId FROM inserted i JOIN deleted d ON i.UserId = d.UserId WHERE i.WorkDetectorRules <> d.WorkDetectorRules OR (i.WorkDetectorRules IS NOT NULL AND d.WorkDetectorRules IS NULL) OR (i.WorkDetectorRules IS NULL AND d.WorkDetectorRules IS NOT NULL))
		END
		IF ( UPDATE (CensorRules) ) 
		BEGIN
			UPDATE [ClientSettings] SET CensorRulesVersion = @nextValue WHERE UserId IN (SELECT i.UserId FROM inserted i JOIN deleted d ON i.UserId = d.UserId WHERE i.CensorRules <> d.CensorRules OR (i.CensorRules IS NOT NULL AND d.CensorRules IS NULL) OR (i.CensorRules IS NULL AND d.CensorRules IS NOT NULL))
		END
		IF ( UPDATE (CollectorRules) ) 
		BEGIN
			UPDATE [ClientSettings] SET CollectorRulesVersion = @nextValue WHERE UserId IN (SELECT i.UserId FROM inserted i JOIN deleted d ON i.UserId = d.UserId WHERE i.CollectorRules <> d.CollectorRules OR (i.CollectorRules IS NOT NULL AND d.CollectorRules IS NULL) OR (i.CollectorRules IS NULL AND d.CollectorRules IS NOT NULL))
		END
		IF (UPDATE(MenuUpdateInterval) OR UPDATE(CaptureWorkItemInterval) OR UPDATE(CaptureActiveWindowInterval) OR UPDATE(CaptureScreenShotInterval)
			OR UPDATE(TimeSyncThreshold) OR UPDATE(JpegQuality) OR UPDATE(JpegScalePct) OR UPDATE(WorkTimeStartInMins)
			OR UPDATE(WorkTimeEndInMins) OR UPDATE(AfterWorkTimeIdleInMins) OR UPDATE(MaxOfflineWorkItems) OR UPDATE(DuringWorkTimeIdleInMins)
			OR UPDATE(DuringWorkTimeIdleManualInterval) OR UPDATE(MaxManualMeetingInterval) OR UPDATE(RuleRestrictions) OR UPDATE(IsMeetingTrackingEnabled)
			OR UPDATE(IsMeetingSubjectMandatory) OR UPDATE(BusyTimeThreshold) OR UPDATE(CoincidentalClientsEnabled) OR UPDATE(IsManualMeetingStartsOnLock)
			OR UPDATE(IsLotusNotesMeetingTrackingEnabled) OR UPDATE(RuleMatchingInterval))
		BEGIN
			UPDATE [ClientSettings] SET ClientSettingsVersion = @nextValue 
			WHERE UserId IN 
			(
				SELECT i.UserId FROM inserted i JOIN deleted d ON i.UserId = d.UserId 
				WHERE i.MenuUpdateInterval <> d.MenuUpdateInterval OR (i.MenuUpdateInterval IS NOT NULL AND d.MenuUpdateInterval IS NULL) OR (i.MenuUpdateInterval IS NULL AND d.MenuUpdateInterval IS NOT NULL)
				OR i.CaptureWorkItemInterval <> d.CaptureWorkItemInterval OR (i.CaptureWorkItemInterval IS NOT NULL AND d.CaptureWorkItemInterval IS NULL) OR (i.CaptureWorkItemInterval IS NULL AND d.CaptureWorkItemInterval IS NOT NULL)
				OR i.CaptureActiveWindowInterval <> d.CaptureActiveWindowInterval OR (i.CaptureActiveWindowInterval IS NOT NULL AND d.CaptureActiveWindowInterval IS NULL) OR (i.CaptureActiveWindowInterval IS NULL AND d.CaptureActiveWindowInterval IS NOT NULL)
				OR i.CaptureScreenShotInterval <> d.CaptureScreenShotInterval OR (i.CaptureScreenShotInterval IS NOT NULL AND d.CaptureScreenShotInterval IS NULL) OR (i.CaptureScreenShotInterval IS NULL AND d.CaptureScreenShotInterval IS NOT NULL)
				OR i.TimeSyncThreshold <> d.TimeSyncThreshold OR (i.TimeSyncThreshold IS NOT NULL AND d.TimeSyncThreshold IS NULL) OR (i.TimeSyncThreshold IS NULL AND d.TimeSyncThreshold IS NOT NULL)
				OR i.JpegQuality <> d.JpegQuality OR (i.JpegQuality IS NOT NULL AND d.JpegQuality IS NULL) OR (i.JpegQuality IS NULL AND d.JpegQuality IS NOT NULL)
				OR i.JpegScalePct <> d.JpegScalePct OR (i.JpegScalePct IS NOT NULL AND d.JpegScalePct IS NULL) OR (i.JpegScalePct IS NULL AND d.JpegScalePct IS NOT NULL)
				OR i.WorkTimeStartInMins <> d.WorkTimeStartInMins OR (i.WorkTimeStartInMins IS NOT NULL AND d.WorkTimeStartInMins IS NULL) OR (i.WorkTimeStartInMins IS NULL AND d.WorkTimeStartInMins IS NOT NULL)
				OR i.WorkTimeEndInMins <> d.WorkTimeEndInMins OR (i.WorkTimeEndInMins IS NOT NULL AND d.WorkTimeEndInMins IS NULL) OR (i.WorkTimeEndInMins IS NULL AND d.WorkTimeEndInMins IS NOT NULL)
				OR i.AfterWorkTimeIdleInMins <> d.AfterWorkTimeIdleInMins OR (i.AfterWorkTimeIdleInMins IS NOT NULL AND d.AfterWorkTimeIdleInMins IS NULL) OR (i.AfterWorkTimeIdleInMins IS NULL AND d.AfterWorkTimeIdleInMins IS NOT NULL)
				OR i.MaxOfflineWorkItems <> d.MaxOfflineWorkItems OR (i.MaxOfflineWorkItems IS NOT NULL AND d.MaxOfflineWorkItems IS NULL) OR (i.MaxOfflineWorkItems IS NULL AND d.MaxOfflineWorkItems IS NOT NULL)
				OR i.DuringWorkTimeIdleInMins <> d.DuringWorkTimeIdleInMins OR (i.DuringWorkTimeIdleInMins IS NOT NULL AND d.DuringWorkTimeIdleInMins IS NULL) OR (i.DuringWorkTimeIdleInMins IS NULL AND d.DuringWorkTimeIdleInMins IS NOT NULL)
				OR i.DuringWorkTimeIdleManualInterval <> d.DuringWorkTimeIdleManualInterval OR (i.DuringWorkTimeIdleManualInterval IS NOT NULL AND d.DuringWorkTimeIdleManualInterval IS NULL) OR (i.DuringWorkTimeIdleManualInterval IS NULL AND d.DuringWorkTimeIdleManualInterval IS NOT NULL)
				OR i.MaxManualMeetingInterval <> d.MaxManualMeetingInterval OR (i.MaxManualMeetingInterval IS NOT NULL AND d.MaxManualMeetingInterval IS NULL) OR (i.MaxManualMeetingInterval IS NULL AND d.MaxManualMeetingInterval IS NOT NULL)
				OR i.RuleRestrictions <> d.RuleRestrictions OR (i.RuleRestrictions IS NOT NULL AND d.RuleRestrictions IS NULL) OR (i.RuleRestrictions IS NULL AND d.RuleRestrictions IS NOT NULL)
				OR i.IsMeetingTrackingEnabled <> d.IsMeetingTrackingEnabled OR (i.IsMeetingTrackingEnabled IS NOT NULL AND d.IsMeetingTrackingEnabled IS NULL) OR (i.IsMeetingTrackingEnabled IS NULL AND d.IsMeetingTrackingEnabled IS NOT NULL)
				OR i.IsMeetingSubjectMandatory <> d.IsMeetingSubjectMandatory OR (i.IsMeetingSubjectMandatory IS NOT NULL AND d.IsMeetingSubjectMandatory IS NULL) OR (i.IsMeetingSubjectMandatory IS NULL AND d.IsMeetingSubjectMandatory IS NOT NULL)
				OR i.BusyTimeThreshold <> d.BusyTimeThreshold OR (i.BusyTimeThreshold IS NOT NULL AND d.BusyTimeThreshold IS NULL) OR (i.BusyTimeThreshold IS NULL AND d.BusyTimeThreshold IS NOT NULL)
				OR i.CoincidentalClientsEnabled <> d.CoincidentalClientsEnabled OR (i.CoincidentalClientsEnabled IS NOT NULL AND d.CoincidentalClientsEnabled IS NULL) OR (i.CoincidentalClientsEnabled IS NULL AND d.CoincidentalClientsEnabled IS NOT NULL)
				OR i.IsManualMeetingStartsOnLock <> d.IsManualMeetingStartsOnLock OR (i.IsManualMeetingStartsOnLock IS NOT NULL AND d.IsManualMeetingStartsOnLock IS NULL) OR (i.IsManualMeetingStartsOnLock IS NULL AND d.IsManualMeetingStartsOnLock IS NOT NULL)
				OR i.IsLotusNotesMeetingTrackingEnabled <> d.IsLotusNotesMeetingTrackingEnabled OR (i.IsLotusNotesMeetingTrackingEnabled IS NOT NULL AND d.IsLotusNotesMeetingTrackingEnabled IS NULL) OR (i.IsLotusNotesMeetingTrackingEnabled IS NULL AND d.IsLotusNotesMeetingTrackingEnabled IS NOT NULL)
				OR i.RuleMatchingInterval <> d.RuleMatchingInterval OR (i.RuleMatchingInterval IS NOT NULL AND d.RuleMatchingInterval IS NULL) OR (i.RuleMatchingInterval IS NULL AND d.RuleMatchingInterval IS NOT NULL)
			)
		END
	END
GO
PRINT N'Altering [dbo].[GetSchemaVersion]...';


GO
-- Don't modify this file, it's used in the build process!
ALTER PROCEDURE [dbo].[GetSchemaVersion]
AS RETURN 5
GO
PRINT N'Creating [dbo].[GetIdForCollectedKey]...';


GO
-- =============================================
-- Author: Zoltan Torok
-- =============================================
Create PROCEDURE [dbo].[GetIdForCollectedKey]
	(
	@key nvarchar(4000),
	@id int OUTPUT
	)
AS
	SET NOCOUNT ON
	SET XACT_ABORT ON

	IF @key IS NULL
	BEGIN
		RAISERROR('@@key cannot be NULL', 16, 1)
		RETURN
	END

declare @hashCode int
SET @hashCode = CHECKSUM(@key)

--optimize for common case, we don't want to put index on (hash,value) or handle deadlocks so we won't use UPDLOCK
SET @id = (
	SELECT [Id]
	  FROM [dbo].[CollectedKeyLookup]
	 WHERE [HashCode] = @hashCode
	   AND [Key] = @key
	)

IF @id IS NOT NULL
	RETURN

BEGIN TRAN

SET @id = (
	SELECT [Id]
	  FROM [dbo].[CollectedKeyLookup] WITH (TABLOCKX, HOLDLOCK)
	 WHERE [HashCode] = @hashCode
	   AND [Key] = @key
	)

IF @id IS NULL
BEGIN
	INSERT INTO [dbo].[CollectedKeyLookup]
			   ([HashCode]
			   ,[Key])
		 VALUES
			   (@hashCode
			   ,@key)

	SET @id = SCOPE_IDENTITY()
END

COMMIT TRAN

	RETURN
GO
PRINT N'Creating [dbo].[GetIdForCollectedValue]...';


GO
-- =============================================
-- Author: Zoltan Torok
-- =============================================
Create PROCEDURE [dbo].[GetIdForCollectedValue]
	(
	@value nvarchar(4000),
	@id int OUTPUT
	)
AS
	SET NOCOUNT ON
	SET XACT_ABORT ON

	IF @value IS NULL
	BEGIN
		RAISERROR('@value cannot be NULL', 16, 1)
		RETURN
	END

declare @hashCode int
SET @hashCode = CHECKSUM(@value)

--optimize for common case, we don't want to put index on (hash,value) or handle deadlocks so we won't use UPDLOCK
SET @id = (
	SELECT [Id]
	  FROM [dbo].[CollectedValueLookup]
	 WHERE [HashCode] = @hashCode
	   AND [Value] = @value
	)

IF @id IS NOT NULL
	RETURN

BEGIN TRAN

SET @id = (
	SELECT [Id]
	  FROM [dbo].[CollectedValueLookup] WITH (TABLOCKX, HOLDLOCK)
	 WHERE [HashCode] = @hashCode
	   AND [Value] = @value
	)

IF @id IS NULL
BEGIN
	INSERT INTO [dbo].[CollectedValueLookup]
			   ([HashCode]
			   ,[Value])
		 VALUES
			   (@hashCode
			   ,@value)

	SET @id = SCOPE_IDENTITY()
END

COMMIT TRAN

	RETURN
GO
PRINT N'Creating [dbo].[InsertCollectedItem]...';


GO
-- =============================================
-- Author: Zoltan Torok
-- =============================================
CREATE PROCEDURE [dbo].[InsertCollectedItem]
	@userId int,
	@createDate datetime,
	@computerId int,
	@keyId int output,
	@valueId int output,
	@key nvarchar(4000),
	@value nvarchar(4000)
AS
BEGIN
	SET NOCOUNT ON;
	SET XACT_ABORT ON

	IF @keyId IS NULL --if specified we won't check if it's correct
		exec GetIdForCollectedKey @key, @keyId output

	IF @valueId IS NULL AND @value IS NOT NULL --if specified we won't check if it's correct
		exec GetIdForCollectedValue @value, @valueId output

	INSERT INTO [dbo].[CollectedItems]
			   ([UserId]
			   ,[CreateDate]
			   ,[ComputerId]
			   ,[KeyId]
			   ,[ValueId])
		 VALUES
			   (@userId
			   ,@createDate
			   ,@computerId
			   ,@keyId
			   ,@valueId)

END
GO
PRINT N'Checking existing data against newly created constraints';


GO
USE [$(DatabaseName)];


GO
ALTER TABLE [dbo].[CollectedItems] WITH CHECK CHECK CONSTRAINT [FK_CollectedItems_CollectedKeyLookup];

ALTER TABLE [dbo].[CollectedItems] WITH CHECK CHECK CONSTRAINT [FK_CollectedItems_CollectedValueLookup];


GO
PRINT N'Update complete.';


GO
