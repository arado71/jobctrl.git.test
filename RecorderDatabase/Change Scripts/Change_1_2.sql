/*
Deployment script for recorder

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
/*
:setvar DatabaseName "recorder"
:setvar DefaultFilePrefix "recorder"
:setvar DefaultDataPath ""
:setvar DefaultLogPath ""
*/

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
PRINT N'Creating [dbo].[WorkTimesById]...';


GO
CREATE TYPE [dbo].[WorkTimesById] AS TABLE (
    [WorkId]   INT NOT NULL,
    [WorkTime] INT NOT NULL,
    PRIMARY KEY CLUSTERED ([WorkId] ASC));


GO
PRINT N'Creating [dbo].[AggregateDailyWorkTimes]...';


GO
CREATE TABLE [dbo].[AggregateDailyWorkTimes] (
    [UserId]           INT        NOT NULL,
    [Day]              DATE       NOT NULL,
    [TotalWorkTime]    AS         ((((([ComputerWorkTime] + [IvrWorkTime]) + [MobileWorkTime]) + [ManualWorkTime]) + [HolidayTime]) + [SickLeaveTime]),
    [NetWorkTime]      INT        NOT NULL,
    [ComputerWorkTime] INT        NOT NULL,
    [IvrWorkTime]      INT        NOT NULL,
    [MobileWorkTime]   INT        NOT NULL,
    [ManualWorkTime]   INT        NOT NULL,
    [HolidayTime]      INT        NOT NULL,
    [SickLeaveTime]    INT        NOT NULL,
    [IsValid]          BIT        NOT NULL,
    [Version]          ROWVERSION NOT NULL,
    CONSTRAINT [PK_AggregateDailyWorkTimes] PRIMARY KEY CLUSTERED ([UserId] ASC, [Day] ASC)
);


GO
PRINT N'Creating [dbo].[AggregateDailyWorkTimes].[IX_AggregateDailyWorkTimes_Day_IsValid_Filtered]...';


GO
CREATE NONCLUSTERED INDEX [IX_AggregateDailyWorkTimes_Day_IsValid_Filtered]
    ON [dbo].[AggregateDailyWorkTimes]([Day] ASC) WHERE ([IsValid]=(0));


GO
PRINT N'Creating [dbo].[AggregateDailyWorkTimesByWorkId]...';


GO
CREATE TABLE [dbo].[AggregateDailyWorkTimesByWorkId] (
    [UserId]        INT  NOT NULL,
    [Day]           DATE NOT NULL,
    [WorkId]        INT  NOT NULL,
    [TotalWorkTime] INT  NOT NULL,
    CONSTRAINT [PK_AggregateDailyWorkTimesByWorkId] PRIMARY KEY CLUSTERED ([UserId] ASC, [Day] ASC, [WorkId] ASC)
);


GO
PRINT N'Creating Default Constraint on [dbo].[AggregateDailyWorkTimes]....';


GO
ALTER TABLE [dbo].[AggregateDailyWorkTimes]
    ADD DEFAULT ((0)) FOR [NetWorkTime];


GO
PRINT N'Creating Default Constraint on [dbo].[AggregateDailyWorkTimes]....';


GO
ALTER TABLE [dbo].[AggregateDailyWorkTimes]
    ADD DEFAULT ((0)) FOR [ComputerWorkTime];


GO
PRINT N'Creating Default Constraint on [dbo].[AggregateDailyWorkTimes]....';


GO
ALTER TABLE [dbo].[AggregateDailyWorkTimes]
    ADD DEFAULT ((0)) FOR [IvrWorkTime];


GO
PRINT N'Creating Default Constraint on [dbo].[AggregateDailyWorkTimes]....';


GO
ALTER TABLE [dbo].[AggregateDailyWorkTimes]
    ADD DEFAULT ((0)) FOR [MobileWorkTime];


GO
PRINT N'Creating Default Constraint on [dbo].[AggregateDailyWorkTimes]....';


GO
ALTER TABLE [dbo].[AggregateDailyWorkTimes]
    ADD DEFAULT ((0)) FOR [ManualWorkTime];


GO
PRINT N'Creating Default Constraint on [dbo].[AggregateDailyWorkTimes]....';


GO
ALTER TABLE [dbo].[AggregateDailyWorkTimes]
    ADD DEFAULT ((0)) FOR [HolidayTime];


GO
PRINT N'Creating Default Constraint on [dbo].[AggregateDailyWorkTimes]....';


GO
ALTER TABLE [dbo].[AggregateDailyWorkTimes]
    ADD DEFAULT ((0)) FOR [SickLeaveTime];


GO
PRINT N'Creating Default Constraint on [dbo].[AggregateDailyWorkTimes]....';


GO
ALTER TABLE [dbo].[AggregateDailyWorkTimes]
    ADD DEFAULT ((0)) FOR [IsValid];


GO
PRINT N'Creating [dbo].[GetIvrEndDateNotNull]...';


GO
-- =============================================
-- Author: Zoltan Torok
-- =============================================
CREATE FUNCTION [dbo].[GetIvrEndDateNotNull] 
(
	@endDate datetime,          --NULL
	@ivrLastCheckDate datetime, --NOT NULL
	@maxEndDate datetime        --NOT NULL
)
RETURNS datetime
AS
BEGIN
	RETURN CASE
		WHEN @endDate IS NOT NULL THEN @endDate
		ELSE CASE
				WHEN @ivrLastCheckDate < @maxEndDate THEN @ivrLastCheckDate
				ELSE @maxEndDate
				END
		END
END
GO
PRINT N'Creating [dbo].[GetDayRange]...';


GO
-- =============================================
-- Author: Zoltan Torok
-- =============================================
CREATE FUNCTION [dbo].[GetDayRange]
(
	@start date, --inclusive
	@end date    --inclusive
)
RETURNS TABLE
RETURN
(
	WITH e1(n) AS
	(
		SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL 
		SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL 
		SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1
	), -- 10
	e2(n) AS (SELECT 1 FROM e1 CROSS JOIN e1 AS b), -- 10*10
	e3(n) AS (SELECT 1 FROM e2 CROSS JOIN e2 AS c) -- 100*100
	--numbers -> SELECT n = ROW_NUMBER() OVER (ORDER BY n) FROM e3 ORDER BY n;
	--SELECT TOP (DATEDIFF(DAY, @start, @end) + 1) [Day] = DATEADD(DAY, ROW_NUMBER() OVER (ORDER BY n)-1, @start) FROM e3 ORDER BY [Day]
	SELECT DATEADD(DAY, Number-1, @start) AS [Day] 
	  FROM
		(
		SELECT TOP (DATEDIFF(DAY, @start, @end) + 1) n = ROW_NUMBER() OVER (ORDER BY n) 
		  FROM e3
		 ORDER BY n
		) O(Number)

)
GO
PRINT N'Creating [dbo].[AggregateWorkItemIntervals_DailyAggrInvalidation_D]...';


GO
CREATE TRIGGER [dbo].[AggregateWorkItemIntervals_DailyAggrInvalidation_D]
    ON [dbo].[AggregateWorkItemIntervals]
    FOR DELETE
    AS
    BEGIN
        SET NoCount ON
		SET XACT_ABORT ON

		declare @rowcnt int
		SET @rowcnt = (SELECT COUNT(*) FROM deleted)

		IF @rowcnt = 1 -- possible fast path
		BEGIN
			declare @startDay date, @endDay date, @userId int

			SELECT @startDay = [dbo].[GetDatePart](StartDate),
				   @endDay = [dbo].[GetDatePart](EndDate),
				   @userId = UserId
			  FROM deleted

			IF @startDay = @endDay --fast path
			BEGIN
				MERGE [dbo].[AggregateDailyWorkTimes] WITH (HOLDLOCK) AS a
				USING (
						SELECT @userId AS [UserId], @startDay AS [Day]
						) AS i
					ON  i.[UserId] = a.[UserId] AND i.[Day] = a.[Day]
					WHEN NOT MATCHED THEN
						INSERT ([UserId], [Day]) VALUES (i.[UserId], i.[Day])
					WHEN MATCHED THEN
						UPDATE SET [IsValid] = 0;
				RETURN
			END
		END

		declare @userDays TABLE (
			[UserId] int NOT NULL,
			[Day] date NOT NULL,
			PRIMARY KEY ([UserId], [Day])
		)

   INSERT INTO @userDays
		SELECT DISTINCT i.[UserId],
			   r.[Day]
		  FROM deleted i
   CROSS APPLY [dbo].[GetDayRange](i.[StartDate], i.[EndDate]) r

		MERGE [dbo].[AggregateDailyWorkTimes] WITH (HOLDLOCK) AS a
		USING (
				SELECT [UserId], [Day]
				  FROM @userDays
			  ) AS i
		   ON  i.[UserId] = a.[UserId] AND i.[Day] = a.[Day]
		 WHEN NOT MATCHED THEN
				INSERT ([UserId], [Day]) VALUES (i.[UserId], i.[Day])
		 WHEN MATCHED THEN
				UPDATE SET [IsValid] = 0;
    END
GO
PRINT N'Creating [dbo].[AggregateWorkItemIntervals_DailyAggrInvalidation_I]...';


GO

CREATE TRIGGER [dbo].[AggregateWorkItemIntervals_DailyAggrInvalidation_I]
    ON [dbo].[AggregateWorkItemIntervals]
    FOR INSERT
    AS
    BEGIN
        SET NoCount ON
		SET XACT_ABORT ON

		declare @rowcnt int
		SET @rowcnt = (SELECT COUNT(*) FROM inserted)

		IF @rowcnt = 1 -- possible fast path
		BEGIN
			declare @startDay date, @endDay date, @userId int

			SELECT @startDay = [dbo].[GetDatePart](StartDate),
				   @endDay = [dbo].[GetDatePart](EndDate),
				   @userId = UserId
			  FROM inserted

			IF @startDay = @endDay --fast path
			BEGIN
				MERGE [dbo].[AggregateDailyWorkTimes] WITH (HOLDLOCK) AS a
				USING (
						SELECT @userId AS [UserId], @startDay AS [Day]
						) AS i
					ON  i.[UserId] = a.[UserId] AND i.[Day] = a.[Day]
					WHEN NOT MATCHED THEN
						INSERT ([UserId], [Day]) VALUES (i.[UserId], i.[Day])
					WHEN MATCHED THEN
						UPDATE SET [IsValid] = 0;
				RETURN
			END
		END

		declare @userDays TABLE (
			[UserId] int NOT NULL,
			[Day] date NOT NULL,
			PRIMARY KEY ([UserId], [Day])
		)

   INSERT INTO @userDays
		SELECT DISTINCT i.[UserId],
			   r.[Day]
		  FROM inserted i
   CROSS APPLY [dbo].[GetDayRange](i.[StartDate], i.[EndDate]) r

		MERGE [dbo].[AggregateDailyWorkTimes] WITH (HOLDLOCK) AS a
		USING (
				SELECT [UserId], [Day]
				  FROM @userDays
			  ) AS i
		   ON  i.[UserId] = a.[UserId] AND i.[Day] = a.[Day]
		 WHEN NOT MATCHED THEN
				INSERT ([UserId], [Day]) VALUES (i.[UserId], i.[Day])
		 WHEN MATCHED THEN
				UPDATE SET [IsValid] = 0;
    END
GO
PRINT N'Creating [dbo].[AggregateWorkItemIntervals_DailyAggrInvalidation_U]...';


GO

CREATE TRIGGER [dbo].[AggregateWorkItemIntervals_DailyAggrInvalidation_U]
    ON [dbo].[AggregateWorkItemIntervals]
    FOR UPDATE
    AS
    BEGIN
        SET NoCount ON
		SET XACT_ABORT ON

		IF UPDATE(UserId) AND EXISTS (SELECT 1 FROM inserted i JOIN deleted d ON i.Id = d.Id WHERE i.UserId <> d.UserId)
		BEGIN
			RAISERROR('Cannot update UserId column',16,1)
			ROLLBACK
			RETURN
		END

		declare @rowcnt int
		SET @rowcnt = (SELECT COUNT(*)
						 FROM inserted i
						 JOIN deleted d ON i.Id = d.Id)

		IF @rowcnt = 1 -- possible fast path
		BEGIN
			declare @startDay date, @endDay date, @userId int

			SELECT @startDay = [dbo].[GetDatePart](CASE WHEN i.StartDate<d.StartDate THEN i.StartDate ELSE d.StartDate END),
				   @endDay = [dbo].[GetDatePart](CASE WHEN i.EndDate>d.EndDate THEN i.EndDate ELSE d.EndDate END),
				   @userId = i.[UserId]
			  FROM inserted i
			  JOIN deleted d ON i.Id = d.Id

			IF @startDay = @endDay --fast path
			BEGIN
				MERGE [dbo].[AggregateDailyWorkTimes] WITH (HOLDLOCK) AS a
				USING (
						SELECT @userId AS [UserId], @startDay AS [Day]
						) AS i
					ON  i.[UserId] = a.[UserId] AND i.[Day] = a.[Day]
					WHEN NOT MATCHED THEN
						INSERT ([UserId], [Day]) VALUES (i.[UserId], i.[Day])
					WHEN MATCHED THEN
						UPDATE SET [IsValid] = 0;
				RETURN
			END
		END

		declare @userDays TABLE (
			[UserId] int NOT NULL,
			[Day] date NOT NULL,
			PRIMARY KEY ([UserId], [Day])
		)

   INSERT INTO @userDays
		SELECT DISTINCT i.[UserId],
			   r.[Day]
		  FROM inserted i
		  JOIN deleted d ON i.Id = d.Id
   CROSS APPLY [dbo].[GetDayRange](CASE WHEN i.StartDate<d.StartDate THEN i.StartDate ELSE d.StartDate END, CASE WHEN i.EndDate>d.EndDate THEN i.EndDate ELSE d.EndDate END) r

		MERGE [dbo].[AggregateDailyWorkTimes] WITH (HOLDLOCK) AS a
		USING (
				SELECT [UserId], [Day]
				  FROM @userDays
			  ) AS i
		   ON  i.[UserId] = a.[UserId] AND i.[Day] = a.[Day]
		 WHEN NOT MATCHED THEN
				INSERT ([UserId], [Day]) VALUES (i.[UserId], i.[Day])
		 WHEN MATCHED THEN
				UPDATE SET [IsValid] = 0;
    END
GO
PRINT N'Creating [dbo].[IvrWorkItems_DailyAggrInvalidation_D]...';


GO
CREATE TRIGGER [dbo].[IvrWorkItems_DailyAggrInvalidation_D]
    ON [dbo].[IvrWorkItems]
    FOR DELETE
    AS
    BEGIN
        SET NoCount ON
		SET XACT_ABORT ON

		declare @rowcnt int
		SET @rowcnt = (SELECT COUNT(*) FROM deleted)

		IF @rowcnt = 1 -- possible fast path
		BEGIN
			declare @startDay date, @endDay date, @userId int

			SELECT @startDay = [dbo].[GetDatePart](StartDate),
				   @endDay = [dbo].[GetDatePart]([dbo].[GetIvrEndDateNotNull](EndDate,IvrLastCheckDate,MaxEndDate)),
				   @userId = UserId
			  FROM deleted

			IF @startDay = @endDay --fast path
			BEGIN
				MERGE [dbo].[AggregateDailyWorkTimes] WITH (HOLDLOCK) AS a
				USING (
						SELECT @userId AS [UserId], @startDay AS [Day]
						) AS i
					ON  i.[UserId] = a.[UserId] AND i.[Day] = a.[Day]
					WHEN NOT MATCHED THEN
						INSERT ([UserId], [Day]) VALUES (i.[UserId], i.[Day])
					WHEN MATCHED THEN
						UPDATE SET [IsValid] = 0;
				RETURN
			END
		END

		declare @userDays TABLE (
			[UserId] int NOT NULL,
			[Day] date NOT NULL,
			PRIMARY KEY ([UserId], [Day])
		)

   INSERT INTO @userDays
		SELECT DISTINCT i.[UserId],
			   r.[Day]
		  FROM deleted i
   CROSS APPLY [dbo].[GetDayRange](i.[StartDate], [dbo].[GetIvrEndDateNotNull](i.EndDate,i.IvrLastCheckDate,i.MaxEndDate)) r

		MERGE [dbo].[AggregateDailyWorkTimes] WITH (HOLDLOCK) AS a
		USING (
				SELECT [UserId], [Day]
				  FROM @userDays
			  ) AS i
		   ON  i.[UserId] = a.[UserId] AND i.[Day] = a.[Day]
		 WHEN NOT MATCHED THEN
				INSERT ([UserId], [Day]) VALUES (i.[UserId], i.[Day])
		 WHEN MATCHED THEN
				UPDATE SET [IsValid] = 0;
    END
GO
PRINT N'Creating [dbo].[IvrWorkItems_DailyAggrInvalidation_I]...';


GO

CREATE TRIGGER [dbo].[IvrWorkItems_DailyAggrInvalidation_I]
    ON [dbo].[IvrWorkItems]
    FOR INSERT
    AS
    BEGIN
        SET NoCount ON
		SET XACT_ABORT ON

		declare @rowcnt int
		SET @rowcnt = (SELECT COUNT(*) FROM inserted)

		IF @rowcnt = 1 -- possible fast path
		BEGIN
			declare @startDay date, @endDay date, @userId int

			SELECT @startDay = [dbo].[GetDatePart](StartDate),
				   @endDay = [dbo].[GetDatePart]([dbo].[GetIvrEndDateNotNull](EndDate,IvrLastCheckDate,MaxEndDate)),
				   @userId = UserId
			  FROM inserted

			IF @startDay = @endDay --fast path
			BEGIN
				MERGE [dbo].[AggregateDailyWorkTimes] WITH (HOLDLOCK) AS a
				USING (
						SELECT @userId AS [UserId], @startDay AS [Day]
						) AS i
					ON  i.[UserId] = a.[UserId] AND i.[Day] = a.[Day]
					WHEN NOT MATCHED THEN
						INSERT ([UserId], [Day]) VALUES (i.[UserId], i.[Day])
					WHEN MATCHED THEN
						UPDATE SET [IsValid] = 0;
				RETURN
			END
		END

		declare @userDays TABLE (
			[UserId] int NOT NULL,
			[Day] date NOT NULL,
			PRIMARY KEY ([UserId], [Day])
		)

   INSERT INTO @userDays
		SELECT DISTINCT i.[UserId],
			   r.[Day]
		  FROM inserted i
   CROSS APPLY [dbo].[GetDayRange](i.[StartDate], [dbo].[GetIvrEndDateNotNull](i.EndDate,i.IvrLastCheckDate,i.MaxEndDate)) r

		MERGE [dbo].[AggregateDailyWorkTimes] WITH (HOLDLOCK) AS a
		USING (
				SELECT [UserId], [Day]
				  FROM @userDays
			  ) AS i
		   ON  i.[UserId] = a.[UserId] AND i.[Day] = a.[Day]
		 WHEN NOT MATCHED THEN
				INSERT ([UserId], [Day]) VALUES (i.[UserId], i.[Day])
		 WHEN MATCHED THEN
				UPDATE SET [IsValid] = 0;
    END
GO
PRINT N'Creating [dbo].[IvrWorkItems_DailyAggrInvalidation_U]...';


GO

CREATE TRIGGER [dbo].[IvrWorkItems_DailyAggrInvalidation_U]
    ON [dbo].[IvrWorkItems]
    FOR UPDATE
    AS
    BEGIN
        SET NoCount ON
		SET XACT_ABORT ON

		IF UPDATE(UserId) AND EXISTS (SELECT 1 FROM inserted i JOIN deleted d ON i.Id = d.Id WHERE i.UserId <> d.UserId)
		BEGIN
			RAISERROR('Cannot update UserId column',16,1)
			ROLLBACK
			RETURN
		END

		declare @rowcnt int
		SET @rowcnt = (SELECT COUNT(*)
						 FROM inserted i
						 JOIN deleted d ON i.Id = d.Id)

		IF @rowcnt = 1 -- possible fast path
		BEGIN
			declare @startDay date, @endDay date, @userId int

			SELECT @startDay = [dbo].[GetDatePart](CASE WHEN i.StartDate<d.StartDate THEN i.StartDate ELSE d.StartDate END),
				   @endDay = [dbo].[GetDatePart](CASE WHEN [dbo].[GetIvrEndDateNotNull](i.EndDate,i.IvrLastCheckDate,i.MaxEndDate)>[dbo].[GetIvrEndDateNotNull](d.EndDate,d.IvrLastCheckDate,d.MaxEndDate) THEN [dbo].[GetIvrEndDateNotNull](i.EndDate,i.IvrLastCheckDate,i.MaxEndDate) ELSE [dbo].[GetIvrEndDateNotNull](d.EndDate,d.IvrLastCheckDate,d.MaxEndDate) END),
				   @userId = i.[UserId]
			  FROM inserted i
			  JOIN deleted d ON i.Id = d.Id

			IF @startDay = @endDay --fast path
			BEGIN
				MERGE [dbo].[AggregateDailyWorkTimes] WITH (HOLDLOCK) AS a
				USING (
						SELECT @userId AS [UserId], @startDay AS [Day]
						) AS i
					ON  i.[UserId] = a.[UserId] AND i.[Day] = a.[Day]
					WHEN NOT MATCHED THEN
						INSERT ([UserId], [Day]) VALUES (i.[UserId], i.[Day])
					WHEN MATCHED THEN
						UPDATE SET [IsValid] = 0;
				RETURN
			END
		END

		declare @userDays TABLE (
			[UserId] int NOT NULL,
			[Day] date NOT NULL,
			PRIMARY KEY ([UserId], [Day])
		)

   INSERT INTO @userDays
		SELECT DISTINCT i.[UserId],
			   r.[Day]
		  FROM inserted i
		  JOIN deleted d ON i.Id = d.Id
   CROSS APPLY [dbo].[GetDayRange](CASE WHEN i.StartDate<d.StartDate THEN i.StartDate ELSE d.StartDate END, CASE WHEN [dbo].[GetIvrEndDateNotNull](i.EndDate,i.IvrLastCheckDate,i.MaxEndDate)>[dbo].[GetIvrEndDateNotNull](d.EndDate,d.IvrLastCheckDate,d.MaxEndDate) THEN [dbo].[GetIvrEndDateNotNull](i.EndDate,i.IvrLastCheckDate,i.MaxEndDate) ELSE [dbo].[GetIvrEndDateNotNull](d.EndDate,d.IvrLastCheckDate,d.MaxEndDate) END) r

		MERGE [dbo].[AggregateDailyWorkTimes] WITH (HOLDLOCK) AS a
		USING (
				SELECT [UserId], [Day]
				  FROM @userDays
			  ) AS i
		   ON  i.[UserId] = a.[UserId] AND i.[Day] = a.[Day]
		 WHEN NOT MATCHED THEN
				INSERT ([UserId], [Day]) VALUES (i.[UserId], i.[Day])
		 WHEN MATCHED THEN
				UPDATE SET [IsValid] = 0;
    END
GO
PRINT N'Creating [dbo].[ManualWorkItems_DailyAggrInvalidation_D]...';


GO

CREATE TRIGGER [dbo].[ManualWorkItems_DailyAggrInvalidation_D]
    ON [dbo].[ManualWorkItems]
    FOR DELETE
    AS
    BEGIN
        SET NoCount ON
		SET XACT_ABORT ON

		declare @rowcnt int
		SET @rowcnt = (SELECT COUNT(*) FROM deleted)

		IF @rowcnt = 1 -- possible fast path
		BEGIN
			declare @startDay date, @endDay date, @userId int

			SELECT @startDay = [dbo].[GetDatePart](StartDate),
				   @endDay = [dbo].[GetDatePart](EndDate),
				   @userId = UserId
			  FROM deleted

			IF @startDay = @endDay --fast path
			BEGIN
				MERGE [dbo].[AggregateDailyWorkTimes] WITH (HOLDLOCK) AS a
				USING (
						SELECT @userId AS [UserId], @startDay AS [Day]
						) AS i
					ON  i.[UserId] = a.[UserId] AND i.[Day] = a.[Day]
					WHEN NOT MATCHED THEN
						INSERT ([UserId], [Day]) VALUES (i.[UserId], i.[Day])
					WHEN MATCHED THEN
						UPDATE SET [IsValid] = 0;
				RETURN
			END
		END

		declare @userDays TABLE (
			[UserId] int NOT NULL,
			[Day] date NOT NULL,
			PRIMARY KEY ([UserId], [Day])
		)

   INSERT INTO @userDays
		SELECT DISTINCT i.[UserId],
			   r.[Day]
		  FROM deleted i
   CROSS APPLY [dbo].[GetDayRange](i.[StartDate], i.[EndDate]) r

		MERGE [dbo].[AggregateDailyWorkTimes] WITH (HOLDLOCK) AS a
		USING (
				SELECT [UserId], [Day]
				  FROM @userDays
			  ) AS i
		   ON  i.[UserId] = a.[UserId] AND i.[Day] = a.[Day]
		 WHEN NOT MATCHED THEN
				INSERT ([UserId], [Day]) VALUES (i.[UserId], i.[Day])
		 WHEN MATCHED THEN
				UPDATE SET [IsValid] = 0;
    END
GO
PRINT N'Creating [dbo].[ManualWorkItems_DailyAggrInvalidation_I]...';


GO

CREATE TRIGGER [dbo].[ManualWorkItems_DailyAggrInvalidation_I]
    ON [dbo].[ManualWorkItems]
    FOR INSERT
    AS
    BEGIN
        SET NoCount ON
		SET XACT_ABORT ON

		declare @rowcnt int
		SET @rowcnt = (SELECT COUNT(*) FROM inserted)

		IF @rowcnt = 1 -- possible fast path
		BEGIN
			declare @startDay date, @endDay date, @userId int

			SELECT @startDay = [dbo].[GetDatePart](StartDate),
				   @endDay = [dbo].[GetDatePart](EndDate),
				   @userId = UserId
			  FROM inserted

			IF @startDay = @endDay --fast path
			BEGIN
				MERGE [dbo].[AggregateDailyWorkTimes] WITH (HOLDLOCK) AS a
				USING (
						SELECT @userId AS [UserId], @startDay AS [Day]
						) AS i
					ON  i.[UserId] = a.[UserId] AND i.[Day] = a.[Day]
					WHEN NOT MATCHED THEN
						INSERT ([UserId], [Day]) VALUES (i.[UserId], i.[Day])
					WHEN MATCHED THEN
						UPDATE SET [IsValid] = 0;
				RETURN
			END
		END

		declare @userDays TABLE (
			[UserId] int NOT NULL,
			[Day] date NOT NULL,
			PRIMARY KEY ([UserId], [Day])
		)

   INSERT INTO @userDays
		SELECT DISTINCT i.[UserId],
			   r.[Day]
		  FROM inserted i
   CROSS APPLY [dbo].[GetDayRange](i.[StartDate], i.[EndDate]) r

		MERGE [dbo].[AggregateDailyWorkTimes] WITH (HOLDLOCK) AS a
		USING (
				SELECT [UserId], [Day]
				  FROM @userDays
			  ) AS i
		   ON  i.[UserId] = a.[UserId] AND i.[Day] = a.[Day]
		 WHEN NOT MATCHED THEN
				INSERT ([UserId], [Day]) VALUES (i.[UserId], i.[Day])
		 WHEN MATCHED THEN
				UPDATE SET [IsValid] = 0;
    END
GO
PRINT N'Creating [dbo].[ManualWorkItems_DailyAggrInvalidation_U]...';


GO

CREATE TRIGGER [dbo].[ManualWorkItems_DailyAggrInvalidation_U]
    ON [dbo].[ManualWorkItems]
    FOR UPDATE
    AS
    BEGIN
        SET NoCount ON
		SET XACT_ABORT ON

		IF UPDATE(UserId) AND EXISTS (SELECT 1 FROM inserted i JOIN deleted d ON i.Id = d.Id WHERE i.UserId <> d.UserId)
		BEGIN
			RAISERROR('Cannot update UserId column',16,1)
			ROLLBACK
			RETURN
		END

		declare @rowcnt int
		SET @rowcnt = (SELECT COUNT(*)
						 FROM inserted i
						 JOIN deleted d ON i.Id = d.Id)

		IF @rowcnt = 1 -- possible fast path
		BEGIN
			declare @startDay date, @endDay date, @userId int

			SELECT @startDay = [dbo].[GetDatePart](CASE WHEN i.StartDate<d.StartDate THEN i.StartDate ELSE d.StartDate END),
				   @endDay = [dbo].[GetDatePart](CASE WHEN i.EndDate>d.EndDate THEN i.EndDate ELSE d.EndDate END),
				   @userId = i.[UserId]
			  FROM inserted i
			  JOIN deleted d ON i.Id = d.Id

			IF @startDay = @endDay --fast path
			BEGIN
				MERGE [dbo].[AggregateDailyWorkTimes] WITH (HOLDLOCK) AS a
				USING (
						SELECT @userId AS [UserId], @startDay AS [Day]
						) AS i
					ON  i.[UserId] = a.[UserId] AND i.[Day] = a.[Day]
					WHEN NOT MATCHED THEN
						INSERT ([UserId], [Day]) VALUES (i.[UserId], i.[Day])
					WHEN MATCHED THEN
						UPDATE SET [IsValid] = 0;
				RETURN
			END
		END

		declare @userDays TABLE (
			[UserId] int NOT NULL,
			[Day] date NOT NULL,
			PRIMARY KEY ([UserId], [Day])
		)

   INSERT INTO @userDays
		SELECT DISTINCT i.[UserId],
			   r.[Day]
		  FROM inserted i
		  JOIN deleted d ON i.Id = d.Id
   CROSS APPLY [dbo].[GetDayRange](CASE WHEN i.StartDate<d.StartDate THEN i.StartDate ELSE d.StartDate END, CASE WHEN i.EndDate>d.EndDate THEN i.EndDate ELSE d.EndDate END) r

		MERGE [dbo].[AggregateDailyWorkTimes] WITH (HOLDLOCK) AS a
		USING (
				SELECT [UserId], [Day]
				  FROM @userDays
			  ) AS i
		   ON  i.[UserId] = a.[UserId] AND i.[Day] = a.[Day]
		 WHEN NOT MATCHED THEN
				INSERT ([UserId], [Day]) VALUES (i.[UserId], i.[Day])
		 WHEN MATCHED THEN
				UPDATE SET [IsValid] = 0;
    END
GO
PRINT N'Creating [dbo].[MobileWorkItems_DailyAggrInvalidation_D]...';


GO
CREATE TRIGGER [dbo].[MobileWorkItems_DailyAggrInvalidation_D]
    ON [dbo].[MobileWorkItems]
    FOR DELETE
    AS
    BEGIN
        SET NoCount ON
		SET XACT_ABORT ON

		declare @rowcnt int
		SET @rowcnt = (SELECT COUNT(*) FROM deleted)

		IF @rowcnt = 1 -- possible fast path
		BEGIN
			declare @startDay date, @endDay date, @userId int

			SELECT @startDay = [dbo].[GetDatePart](StartDate),
				   @endDay = [dbo].[GetDatePart](EndDate),
				   @userId = UserId
			  FROM deleted

			IF @startDay = @endDay --fast path
			BEGIN
				MERGE [dbo].[AggregateDailyWorkTimes] WITH (HOLDLOCK) AS a
				USING (
						SELECT @userId AS [UserId], @startDay AS [Day]
						) AS i
					ON  i.[UserId] = a.[UserId] AND i.[Day] = a.[Day]
					WHEN NOT MATCHED THEN
						INSERT ([UserId], [Day]) VALUES (i.[UserId], i.[Day])
					WHEN MATCHED THEN
						UPDATE SET [IsValid] = 0;
				RETURN
			END
		END

		declare @userDays TABLE (
			[UserId] int NOT NULL,
			[Day] date NOT NULL,
			PRIMARY KEY ([UserId], [Day])
		)

   INSERT INTO @userDays
		SELECT DISTINCT i.[UserId],
			   r.[Day]
		  FROM deleted i
   CROSS APPLY [dbo].[GetDayRange](i.[StartDate], i.[EndDate]) r

		MERGE [dbo].[AggregateDailyWorkTimes] WITH (HOLDLOCK) AS a
		USING (
				SELECT [UserId], [Day]
				  FROM @userDays
			  ) AS i
		   ON  i.[UserId] = a.[UserId] AND i.[Day] = a.[Day]
		 WHEN NOT MATCHED THEN
				INSERT ([UserId], [Day]) VALUES (i.[UserId], i.[Day])
		 WHEN MATCHED THEN
				UPDATE SET [IsValid] = 0;
    END
GO
PRINT N'Creating [dbo].[MobileWorkItems_DailyAggrInvalidation_I]...';


GO

CREATE TRIGGER [dbo].[MobileWorkItems_DailyAggrInvalidation_I]
    ON [dbo].[MobileWorkItems]
    FOR INSERT
    AS
    BEGIN
        SET NoCount ON
		SET XACT_ABORT ON

		declare @rowcnt int
		SET @rowcnt = (SELECT COUNT(*) FROM inserted)

		IF @rowcnt = 1 -- possible fast path
		BEGIN
			declare @startDay date, @endDay date, @userId int

			SELECT @startDay = [dbo].[GetDatePart](StartDate),
				   @endDay = [dbo].[GetDatePart](EndDate),
				   @userId = UserId
			  FROM inserted

			IF @startDay = @endDay --fast path
			BEGIN
				MERGE [dbo].[AggregateDailyWorkTimes] WITH (HOLDLOCK) AS a
				USING (
						SELECT @userId AS [UserId], @startDay AS [Day]
						) AS i
					ON  i.[UserId] = a.[UserId] AND i.[Day] = a.[Day]
					WHEN NOT MATCHED THEN
						INSERT ([UserId], [Day]) VALUES (i.[UserId], i.[Day])
					WHEN MATCHED THEN
						UPDATE SET [IsValid] = 0;
				RETURN
			END
		END

		declare @userDays TABLE (
			[UserId] int NOT NULL,
			[Day] date NOT NULL,
			PRIMARY KEY ([UserId], [Day])
		)

   INSERT INTO @userDays
		SELECT DISTINCT i.[UserId],
			   r.[Day]
		  FROM inserted i
   CROSS APPLY [dbo].[GetDayRange](i.[StartDate], i.[EndDate]) r

		MERGE [dbo].[AggregateDailyWorkTimes] WITH (HOLDLOCK) AS a
		USING (
				SELECT [UserId], [Day]
				  FROM @userDays
			  ) AS i
		   ON  i.[UserId] = a.[UserId] AND i.[Day] = a.[Day]
		 WHEN NOT MATCHED THEN
				INSERT ([UserId], [Day]) VALUES (i.[UserId], i.[Day])
		 WHEN MATCHED THEN
				UPDATE SET [IsValid] = 0;
    END
GO
PRINT N'Creating [dbo].[MobileWorkItems_DailyAggrInvalidation_U]...';


GO

CREATE TRIGGER [dbo].[MobileWorkItems_DailyAggrInvalidation_U]
    ON [dbo].[MobileWorkItems]
    FOR UPDATE
    AS
    BEGIN
        SET NoCount ON
		SET XACT_ABORT ON

		IF UPDATE(UserId) AND EXISTS (SELECT 1 FROM inserted i JOIN deleted d ON i.Id = d.Id WHERE i.UserId <> d.UserId)
		BEGIN
			RAISERROR('Cannot update UserId column',16,1)
			ROLLBACK
			RETURN
		END

		declare @rowcnt int
		SET @rowcnt = (SELECT COUNT(*)
						 FROM inserted i
						 JOIN deleted d ON i.Id = d.Id)

		IF @rowcnt = 1 -- possible fast path
		BEGIN
			declare @startDay date, @endDay date, @userId int

			SELECT @startDay = [dbo].[GetDatePart](CASE WHEN i.StartDate<d.StartDate THEN i.StartDate ELSE d.StartDate END),
				   @endDay = [dbo].[GetDatePart](CASE WHEN i.EndDate>d.EndDate THEN i.EndDate ELSE d.EndDate END),
				   @userId = i.[UserId]
			  FROM inserted i
			  JOIN deleted d ON i.Id = d.Id

			IF @startDay = @endDay --fast path
			BEGIN
				MERGE [dbo].[AggregateDailyWorkTimes] WITH (HOLDLOCK) AS a
				USING (
						SELECT @userId AS [UserId], @startDay AS [Day]
						) AS i
					ON  i.[UserId] = a.[UserId] AND i.[Day] = a.[Day]
					WHEN NOT MATCHED THEN
						INSERT ([UserId], [Day]) VALUES (i.[UserId], i.[Day])
					WHEN MATCHED THEN
						UPDATE SET [IsValid] = 0;
				RETURN
			END
		END

		declare @userDays TABLE (
			[UserId] int NOT NULL,
			[Day] date NOT NULL,
			PRIMARY KEY ([UserId], [Day])
		)

   INSERT INTO @userDays
		SELECT DISTINCT i.[UserId],
			   r.[Day]
		  FROM inserted i
		  JOIN deleted d ON i.Id = d.Id
   CROSS APPLY [dbo].[GetDayRange](CASE WHEN i.StartDate<d.StartDate THEN i.StartDate ELSE d.StartDate END, CASE WHEN i.EndDate>d.EndDate THEN i.EndDate ELSE d.EndDate END) r

		MERGE [dbo].[AggregateDailyWorkTimes] WITH (HOLDLOCK) AS a
		USING (
				SELECT [UserId], [Day]
				  FROM @userDays
			  ) AS i
		   ON  i.[UserId] = a.[UserId] AND i.[Day] = a.[Day]
		 WHEN NOT MATCHED THEN
				INSERT ([UserId], [Day]) VALUES (i.[UserId], i.[Day])
		 WHEN MATCHED THEN
				UPDATE SET [IsValid] = 0;
    END
GO
PRINT N'Altering [dbo].[GetSchemaVersion]...';


GO
-- Don't modify this file, it's used in the build process!
ALTER PROCEDURE [dbo].[GetSchemaVersion]
AS RETURN 2
GO
PRINT N'Creating [dbo].[UpdateDailyAggregateWorkTimeTables]...';


GO
-- =============================================
-- Author: Zoltan Torok
-- =============================================
CREATE PROCEDURE [dbo].[UpdateDailyAggregateWorkTimeTables]
	@userId int,
	@day date,
	@netWorkTime int,
	@computerWorkTime int,
	@ivrWorkTime int,
	@mobileWorkTime int,
	@manualWorkTime int,
	@holidayTime int,
	@sickLeaveTime int,
	@oldVersion rowversion,
	@workTimesById WorkTimesById READONLY
AS
	SET NOCOUNT ON
	SET XACT_ABORT ON

	;
	WITH a AS
	(
		SELECT *
		  FROM [dbo].[AggregateDailyWorkTimesByWorkId] WITH (HOLDLOCK)
		 WHERE [UserId] = @userId AND [Day] = @day
	)
	MERGE INTO a
	USING (
			SELECT [WorkId], [WorkTime]
			  FROM @workTimesById
			) AS i
		ON i.[WorkId] = a.[WorkId]
		WHEN NOT MATCHED THEN
			INSERT ([UserId], [Day], [WorkId], [TotalWorkTime]) VALUES (@userId, @day, i.[WorkId], i.[WorkTime])
		WHEN MATCHED THEN
			UPDATE SET a.[TotalWorkTime] = i.[WorkTime]
		WHEN NOT MATCHED BY SOURCE THEN
			DELETE
	;

	WITH a AS
	(
		SELECT *
		  FROM [dbo].[AggregateDailyWorkTimes] WITH (HOLDLOCK)
		 WHERE [UserId] = @userId AND [Day] = @day
	)
	MERGE INTO a
	USING (
			SELECT @userId AS [UserId], @day AS [Day]
			) AS i
		ON  i.[UserId] = a.[UserId] AND i.[Day] = a.[Day]
		WHEN NOT MATCHED THEN
			INSERT
			   ([UserId]
			   ,[Day]
			   ,[NetWorkTime]
			   ,[ComputerWorkTime]
			   ,[IvrWorkTime]
			   ,[MobileWorkTime]
			   ,[ManualWorkTime]
			   ,[HolidayTime]
			   ,[SickLeaveTime]
			   ,[IsValid])
			VALUES
			   (@userId
			   ,@day
			   ,@netWorkTime
			   ,@computerWorkTime
			   ,@ivrWorkTime
			   ,@mobileWorkTime
			   ,@manualWorkTime
			   ,@holidayTime
			   ,@sickLeaveTime
			   ,1)
		WHEN MATCHED THEN
			UPDATE SET [IsValid] = CASE WHEN a.Version = @oldVersion THEN 1 ELSE 0 END
			   ,[NetWorkTime] = @netWorkTime
			   ,[ComputerWorkTime] = @computerWorkTime
			   ,[IvrWorkTime] = @ivrWorkTime
			   ,[MobileWorkTime] = @mobileWorkTime
			   ,[ManualWorkTime] = @manualWorkTime
			   ,[HolidayTime] = @holidayTime
			   ,[SickLeaveTime] = @sickLeaveTime
	;

RETURN 0
GO
PRINT N'Update complete.';


GO
