/*
Deployment script for recorder

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
/*
:setvar DatabaseName "recorder"
:setvar DefaultFilePrefix "recorder"
:setvar DefaultDataPath ""
:setvar DefaultLogPath ""
*/

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
PRINT N'Altering [dbo].[GetSchemaVersion]...';


GO
-- Don't modify this file, it's used in the build process!
ALTER PROCEDURE [dbo].[GetSchemaVersion]
AS RETURN 4
GO
PRINT N'Altering [dbo].[UpdateDailyAggregateWorkTimeTables]...';


GO
-- =============================================
-- Author: Zoltan Torok
--
-- We could use ISOLATION LEVEL SERIALIZABLE and do the operations on the two tables in the same order in one transaction 
-- i.e. Update [AggregateDailyWorkTimes] and then [AggregateDailyWorkTimesByWorkId], also when reading, first we select 
-- from [AggregateDailyWorkTimes] and then [AggregateDailyWorkTimesByWorkId] also in one SERIALIZABLE transaction.
-- But if we tolerate some race conditions we could avoid transactions and Update [AggregateDailyWorkTimesByWorkId] and
-- then [AggregateDailyWorkTimes], and read from [AggregateDailyWorkTimes] and then [AggregateDailyWorkTimesByWorkId].
-- So the version is updated as the last operation and is read as the first one.
-- In this case we could have the new data from [AggregateDailyWorkTimesByWorkId] with old data from [AggregateDailyWorkTimes]
-- including the version, but eventually we will have to get the latest version with consistent data.
-- =============================================
ALTER PROCEDURE [dbo].[UpdateDailyAggregateWorkTimeTables]
	@userId int,
	@day date,
	@netWorkTime int,
	@computerWorkTime int,
	@ivrWorkTime int,
	@mobileWorkTime int,
	@manualWorkTime int,
	@holidayTime int,
	@sickLeaveTime int,
	@oldVersion rowversion,
	@workTimesById WorkTimesById READONLY
AS
	SET NOCOUNT ON
	SET XACT_ABORT ON

	;
	WITH a AS
	(
		SELECT *
		  FROM [dbo].[AggregateDailyWorkTimesByWorkId] WITH (HOLDLOCK)
		 WHERE [UserId] = @userId AND [Day] = @day
	)
	MERGE INTO a
	USING (
			SELECT [WorkId], [WorkTime]
			  FROM @workTimesById
			) AS i
		ON i.[WorkId] = a.[WorkId]
		WHEN NOT MATCHED THEN
			INSERT ([UserId], [Day], [WorkId], [TotalWorkTime]) VALUES (@userId, @day, i.[WorkId], i.[WorkTime])
		WHEN MATCHED THEN
			UPDATE SET a.[TotalWorkTime] = i.[WorkTime]
		WHEN NOT MATCHED BY SOURCE THEN
			DELETE
	;

	WITH a AS
	(
		SELECT *
		  FROM [dbo].[AggregateDailyWorkTimes] WITH (HOLDLOCK)
		 WHERE [UserId] = @userId AND [Day] = @day
	)
	MERGE INTO a
	USING (
			SELECT @userId AS [UserId], @day AS [Day]
			) AS i
		ON  i.[UserId] = a.[UserId] AND i.[Day] = a.[Day]
		WHEN NOT MATCHED THEN
			INSERT
			   ([UserId]
			   ,[Day]
			   ,[NetWorkTime]
			   ,[ComputerWorkTime]
			   ,[IvrWorkTime]
			   ,[MobileWorkTime]
			   ,[ManualWorkTime]
			   ,[HolidayTime]
			   ,[SickLeaveTime]
			   ,[IsValid])
			VALUES
			   (@userId
			   ,@day
			   ,@netWorkTime
			   ,@computerWorkTime
			   ,@ivrWorkTime
			   ,@mobileWorkTime
			   ,@manualWorkTime
			   ,@holidayTime
			   ,@sickLeaveTime
			   ,1)
		WHEN MATCHED THEN
			UPDATE SET [IsValid] = CASE WHEN a.Version = @oldVersion THEN 1 ELSE 0 END
			   ,[NetWorkTime] = @netWorkTime
			   ,[ComputerWorkTime] = @computerWorkTime
			   ,[IvrWorkTime] = @ivrWorkTime
			   ,[MobileWorkTime] = @mobileWorkTime
			   ,[ManualWorkTime] = @manualWorkTime
			   ,[HolidayTime] = @holidayTime
			   ,[SickLeaveTime] = @sickLeaveTime
	;

RETURN 0
GO
PRINT N'Creating [dbo].[GetLatestDailyAggregateWorkTimeTablesForUser]...';


GO
-- =============================================
-- Author: Zoltan Torok
--
-- There are several races here so be careful (more info in [UpdateDailyAggregateWorkTimeTables])
-- =============================================
CREATE PROCEDURE [dbo].[GetLatestDailyAggregateWorkTimeTablesForUser]
	@userId int,
	@oldVersion BINARY(8)
AS
	SET NOCOUNT ON

	IF NULLIF(object_id('tempdb..#firstresult'), 0) IS NOT NULL DROP TABLE #firstresult

	DECLARE @maxVersion BINARY(8) = (SELECT MIN_ACTIVE_ROWVERSION())

	SELECT t.[UserId]
		  ,t.[Day]
		  ,t.[TotalWorkTime]
		  ,t.[NetWorkTime]
		  ,t.[ComputerWorkTime]
		  ,t.[IvrWorkTime]
		  ,t.[MobileWorkTime]
		  ,t.[ManualWorkTime]
		  ,t.[HolidayTime]
		  ,t.[SickLeaveTime]
		  --,t.[IsValid]
		  ,t.[Version]
	  INTO #firstresult
	  FROM [dbo].[AggregateDailyWorkTimes] t
	 WHERE t.[UserId] = @userId
	   AND [Version] > @oldVersion
	   AND [Version] < @maxVersion
	   AND [IsValid] = 1

	SELECT * 
	  FROM #firstresult

	SELECT w.[UserId]
		  ,w.[Day]
		  ,w.[WorkId]
		  ,w.[TotalWorkTime]
	  FROM [dbo].[AggregateDailyWorkTimesByWorkId] w
	  JOIN #firstresult d ON d.[Day] = w.[Day]
	 WHERE w.[UserId] = @userId

RETURN 0
GO
PRINT N'Update complete.';


GO
